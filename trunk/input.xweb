<?xml version="1.0" standalone="no"?>
<!DOCTYPE xweb PUBLIC "-//NDW-WMR//DTD DocBook XML V4.1.2-based Extension XWeb V1.0//EN"
                      "file:///opt/litprog/dtd/xweb.dtd" [
<!ENTITY % entities SYSTEM "entities.inc.dtd">
%entities;
<!ENTITY pkg      "&inname;">
]>

<article xmlns:src="http://nwalsh.com/xmlns/litprog/fragment"
         xmlns:xsl="http://www.w3.org/1999/XSL/Transform">


<!-- Article meta-data -->
<articleinfo>
<title>&prog; Input Services</title>

<author>
<firstname>Chip</firstname>
<surname>Richards</surname>
</author>

<address><email>chipr@niestu.com</email></address>
<publisher>
<publishername>NiEstu</publishername>
<address><otheraddr><ulink url="&site;/allegra/"></ulink></otheraddr></address>
</publisher>

<releaseinfo>Version 1.0</releaseinfo>
<date>30 December 2003</date>

<legalnotice>
<para>This code is released under the terms of the <ulink
url="http://www.gnu.org/licenses/gpl.html">GNU General Public License</ulink>,
version 2.</para>
</legalnotice>
</articleinfo>


<!-- The Input task -->
<section id="input-task">
<title>The Input Task</title>

<para>The input task is the starting point for all on-line activity.  In
&prog;, the socket connection to the IRC server is represented by the standard
input stream, allowing the user to play the role of the IRC server, using
<ulink url="&refman;">a set of simple commands</ulink> to simulate actions
and exercise the various parts of the program.  In &prog;, this task has the
additional responsibility of deciding whether a given message from the server
is actually intended for the bot, or is regular channel traffic.  This
decision is required because the bot appears to the server as just another IRC
user, and all users on a channel get all messages sent to the channel by every
user.  For &prog;, every input from the user is intended for the program, so
no such decision need be made.  Once input is recognized as being directed at
the bot, it is formatted (very simply) and placed on the command task's
request queue.</para>

<section>
<title>Input Loop</title>
<para>
The heart of the input task is an endless loop, which reads input, processes
it (in this case, simply by converting it to the command-request format), and
places the request on the command queue.

<src:fragment id="input-loop">
      loop
         Got_Input := false;
         begin
            IRC.Read (Input_Message);
            Got_Input := true;
            Dbg (Input_Name, "Got " &amp; To_String (Input_Message.Prefix) &amp; ", " &amp; To_String (Input_Message.Command) &amp; ", " &amp; To_String (Input_Message.Params));

         exception
            when IRC.Connect_Error =>
               IRC.Close_Server;
               IRC.Open_Server (&cfgname;.Get_Value (&cfgname;.Item_Host), positive'Value (&cfgname;.Get_Value (&cfgname;.Item_Port)));
               Info (Input_Name, "Reconnect to " &amp; &cfgname;.Get_Value (&cfgname;.Item_Host) &amp; ":" &amp; &cfgname;.Get_Value (&cfgname;.Item_Port));

            when others =>
               null;  -- fill me in someday
         end;

         if Got_Input then
            &pingname;.Ping_Task.Input_Received;
            declare
               Cmd       : string := To_Lower (To_String (Input_Message.Command));
               Nick      : string := To_Lower (&cfgname;.Get_Value (&cfgname;.Item_Nick));
               Message   : Unbounded_String := To_Unbounded_String (To_Lower (To_String (Input_Message.Params)));
               Shorthand : string := &cfgname;.Get_Value (&cfgname;.Item_Shorthand);
               Params    : IRC.Param_Arr;
               Count     : IRC.Param_Count;
               Has_SHand : boolean;
               Has_Nick  : boolean;
            begin
               if    Cmd = "ping"        then
                  Dbg (Input_Name, "Ping: " &amp; To_String (Input_Message.Params));
                  Command_Request.Operation := &cmdname;.Pong_Operation;
                  Command_Request.Data      := Input_Message.Params;
                  &cmdname;.Requests.Enqueue (Command_Request);
               elsif Cmd = "privmsg"     then
                  Has_SHand := Shorthand'Length &gt; 0 and then Index (Message, Shorthand) > 0;
                  Has_Nick  := Index (Message, Nick) > 0;
                  if Has_SHand or else Has_Nick then
                     IRC.Parse_Params (Input_Message.Params, Params, Count);
                     Has_SHand := not Has_Nick and then Count &gt;= 2 and then Index (Params (2), Shorthand) = 1;
                  end if;
                  if Has_SHand or else Has_Nick then
                     Dbg (Input_Name, "Recognized message from " &amp; To_String (Input_Message.Prefix) &amp; ": " &amp;
                                      To_String (Input_Message.Params));
                     Command_Request.Operation := &cmdname;.Message_Operation;
                     Command_Request.Origin    := Input_Message.Prefix;
                     Command_Request.Target    := IRC.Null_Field;
                     Command_Request.Data      := IRC.Null_Field;
                     if Count &gt;= 1 then
                        Command_Request.Target    := Params (1);
                     end if;
                     if Count &gt;= 2 then
                        Command_Request.Data      := Params (2);
                     end if;
                     Command.Requests.Enqueue (Command_Request);
                  end if;
               elsif Numeric_Reply (Cmd) then
                  Dbg (Input_Name, "Reply " &amp; Cmd &amp; ": " &amp; To_String (Input_Message.Params));
                  Command_Request.Operation := &cmdname;.Reply_Operation;
                  Command_Request.Reply     := &cmdname;.Reply_Type (Cmd);
                  Command_Request.Data      := Input_Message.Params;
                  &cmdname;.Requests.Enqueue (Command_Request);
               end if;
            end;
         else
            Dbg (Input_Name, "Login requested");
            Command_Request.Operation := &cmdname;.Login_Operation;
            &cmdname;.Requests.Enqueue (Command_Request);
         end if;
      end loop;
</src:fragment>

The task spends most of its time sitting on the
<methodname>Get_Line</methodname> statement, waiting for the user to enter a
command.  This simulates the real program's behavior of sitting on a socket
read.  The loop is terminated when the task is aborted by the command task,
when it recognizes a <quote>quit</quote> command.
</para>

<para id="no-prompt">Note that the input task does not issue any prompt to
let the user know that it is ready to accept input.  If we simply added a
<methodname>Put</methodname> or <methodname>Put_Line</methodname> call before
the <methodname>Get_Line</methodname>, the results would be unsatisfactory, if
perhaps instructive.  (Yes, we tried it during development.  Don't laugh.)
The problem is, because of the concurrent nature of task execution, the order
in which the prompt, and the output from the previous command, are written to
the standard output stream is indeterminate.  Just as often, the prompt is
written before the pending output line, producing a very unappealing and
confusing transcript.</para>

<para>Even if we used the output queue instead of direct I/O calls, the
order could not be predicted without additional synchronization among the
tasks.  Such a mechanism would be simple to implement, but since there is no
analogue of it in &prog;, it was not deemed sufficiently important to be
included.  So you just have to trust that &prog; is ready to accept input
after execution begins.  If you absolutely must have a prompt, well, you have
the source, so have fun!</para>
</section>

<section>
<title>Check for Numeric Server Replies</title>

<para>Some of what the server sends are replies in the form of a three-digit
numeric response code.  This function checks a command/reply field to see if
it is such a response, and returns true if so, false if not.</para>

<src:fragment id="ck-num-reply">
      function Numeric_Reply (Field:  string) return boolean is
      begin  -- Numeric_Reply
         return Field'Length = &cmdname;.Reply_Type'Length and then
                (Is_Digit (Field (1)) and Is_Digit (Field (2)) and Is_Digit (Field (3)));
      end Numeric_Reply;
</src:fragment>

</section>

<section>
<title>Input Task Declarations</title>

<para>
The input loop uses these three variables:

<itemizedlist>
<listitem>
<para><literal>Input_Line</literal> - The string which contains the input from the
user.  This simulates a message from the IRC server, though the commands have
a much simpler format than IRC messages.  Its size is set by the
<literal>Input_Line_Max</literal> constant.  Its value is set by the standard
<methodname>Get_Line</methodname> library function.</para>
</listitem>

<listitem>
<para><literal>Input_Length</literal> - The length in characters of the
line the user has typed.  Set by the standard
<methodname>Get_Line</methodname> library function.</para>
</listitem>

<listitem>
<para><literal>Command_Request</literal> - The request variable to be
placed on the command task's request queue.  Its value is simply copied from
the input line via the <methodname>To_Unbounded_String</methodname> standard
library procedure.</para>
</listitem>
</itemizedlist>

   <src:fragment id="input-decls">

      &pkg;_Name:  constant string := "&pkg;";

<src:fragref linkend="ck-num-reply"/>

      Got_Input:        boolean;
      Input_Message:    IRC.Message_Rec;
      Command_Request:  &cmdname;.Request_Rec;
</src:fragment>

The value for <literal>Input_Line_Max</literal> was chosen arbitrarily, as
being <quote>big enough</quote> to accomodate any line the user is likely to
type during testing.  If the user enters more characters than this, it will be
returned as multiple lines.  So, don't do that!
</para>
</section>

<section>
<title>Input Task Body</title>
<para>
The task's body contains only the processing loop, and its required
declarations.

<src:fragment id="input-task-body">
   task body Input_Task_Type is
<src:fragref linkend="input-decls"/>
   begin  -- Input_Task_Type
      IRC.Open_Server (&cfgname;.Get_Value (&cfgname;.Item_Host), positive'Value (&cfgname;.Get_Value (&cfgname;.Item_Port)));
      Command_Request.Operation := &cmdname;.Login_Operation;
      &cmdname;.Requests.Enqueue (Command_Request);
<src:fragref linkend="input-loop"/>
   end Input_Task_Type;
</src:fragment>
</para>
</section>

<section>
<title>Input Task Package</title>
<para>
For compilation purposes, the task is contained in a package.  The task is its
only content, since no other packages depend on it.  The external dependencies
are:

<itemizedlist>
<listitem>
<para><classname>Ada.Text_IO</classname> - Provides the procedure
<methodname>Get_Line</methodname>, which is used to read commands from the
user.</para>
</listitem>

<listitem>
<para><classname>Ada.Strings.Unbounded</classname> - Provides the function
<methodname>To_Unbounded_String</methodname>, used to convert the fixed-length
input command string to the unbounded-string format required by the command
task.</para>
</listitem>

<listitem>
<para><classname>&cmdname;</classname> - The command task's package, which
provides the data type for the command-task queue requests, and the
<methodname>Enqueue</methodname> procedure, which adds the request to the
command request queue.</para>
</listitem>

<listitem>
<para><classname>&cfgname;</classname> - The configuration task, used to fetch
various values from the program configuration database.</para>
</listitem>

<listitem>
<para><classname>&pingname;</classname> - The ping task's package, which provides
the <methodname>Input_Received</methodname> task entry, which the input task
uses to tell the ping task that some input was seen coming from <quote>the
link</quote> (in &prog;'s case, the user).</para>
</listitem>
</itemizedlist>

Visibility is provided to the standard library packages via a
<command>use</command> clause; references to items declared in the
<classname>&cmdname;</classname> package must be fully qualified.

<src:fragment id="input-pkg-body">
with
   Ada.Text_IO,
   Ada.Characters.Handling,
   Ada.Strings.Unbounded,
   &cmdname;,
   &cfgname;,
   &ircname;,
   &logname;,
   &pingname;;

use
   Ada.Text_IO,
   Ada.Characters.Handling,
   Ada.Strings.Unbounded,
   &logname;;

package body Input is

   &pkg;_Name:  constant string := "&pkg;";

<src:fragref linkend="input-task-body"/>

end Input;
</src:fragment>
</para>

<para>
The input task's package spec is similar to that of <ulink
url="&pingpkg;">the ping task</ulink>; they are both a little different
from the specs of the other task packages.  Since the command task needs to be
able to abort the input task when a <quote>quit</quote> command is processed,
it needs a way to identify the input task to the <command>abort</command>
statement.  Thus the input and ping task package's specs declare a task type,
and a variable of that type, instead of the anonymous task types of most of
the other tasks.

<src:fragment id="input-pkg-spec">
package Input is
   task type Input_Task_Type;
   Input_Task:  Input_Task_Type;
end Input;
</src:fragment>
</para>
</section>
</section>

</article>
