<?xml version="1.0" standalone="no"?>
<!DOCTYPE xweb PUBLIC "-//NDW-WMR//DTD DocBook XML V4.1.2-based Extension XWeb V1.0//EN"
                      "file:///opt/litprog/dtd/xweb.dtd" [
<!ENTITY % entities SYSTEM "entities.inc.dtd">
%entities;
]>

<article xmlns:src="http://nwalsh.com/xmlns/litprog/fragment"
         xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

<!-- Article meta-data -->
<articleinfo>
<title>&prog; File Access Package</title>

<author>
<firstname>Chip</firstname>
<surname>Richards</surname>
</author>

<address><email>chipr@niestu.com</email></address>
<publisher>
<publishername>NiEstu</publishername>
<address><otheraddr><ulink url="&site;/allegra/"></ulink></otheraddr></address>
</publisher>

<releaseinfo>Version &version;</releaseinfo>
<date>&builddate;</date>

<legalnotice>
<para>This code is released under the terms of the <ulink
url="http://www.gnu.org/licenses/gpl.html">GNU General Public License</ulink>,
version 2.</para>
</legalnotice>
</articleinfo>

<!-- The File task -->
<section id="file-task">
<title>The File Task</title>

<para>The file task accepts requests for access to files on the host
filesystem where the bot is executing.  In &prog;, it simply reports that such
requests have been received, by placing a message on the output queue; in
&prog;, once the task is actually implemented, it will read and write files
as directed by the requests it receives.</para>

<section>
<title>File Request Processing Loop</title>
<para>
The heart of the file task is an endless loop.  It removes a request from the
file request queue and examines its <literal>Operation</literal> field.  If it
is a file access request operation, it adds some identifying text to the data
string and places the resulting string on the output queue.  If it is a
shutdown request, the loop terminates, which terminates the task.

<src:fragment id="file-loop">
      loop
         Requests.Dequeue (Request);
         exit when Request.Operation = Shutdown_Operation;
         Output_Request.Operation := Output.Message_Operation;
         Output_Request.Destination := Request.Destination;
         Output_Request.Data := "File request: " &amp; Request.Data;
         Output.Requests.Enqueue (Output_Request);
      end loop;
</src:fragment>

The task spends most of its time sitting on the
<methodname>Dequeue</methodname> statement, waiting for a file access request
to be placed in its queue by <link linkend="command-task">the command
task</link>.
</para>
</section>

<section>
<title>File Task Declarations</title>

<para>
The file loop uses these variables:

<itemizedlist>
<listitem>
<para><literal>Request</literal> - Local variable of the type of the
file-queue entries, used to receive the next item taken from the request
queue.</para>
</listitem>

<listitem>
<para><literal>Output_Request</literal> - Request-queue variable for the
output task.  Used to report requests received by the file task.</para>
</listitem>
</itemizedlist>

<src:fragment id="file-decls">
      Request:           Request_Rec;
      Output_Request:    Output.Request_Rec;
</src:fragment>

</para>
</section>

<section>
<title>File Task Body</title>
<para>
The task's body contains only the processing loop, and its required
declarations:

<src:fragment id="file-task-body">

   task body File_Task is
<src:fragref linkend="file-decls"/>

   begin  -- File_Task
<src:fragref linkend="file-loop"/>
   end File_Task;

</src:fragment>
</para>
</section>

<section>
<title>File Task Package</title>

<section>
<title>File Package Body</title>
<para>
For compilation purposes, the task is contained in a package.  The package
body contains only the (anonymous) task object.  The external dependencies
are:

<itemizedlist>
<listitem>
<para><classname>Ada.Strings.Unbounded</classname> - Provides the
<quote>&amp;</quote> operator, used to concatenate the informational message
to the request data..</para>
</listitem>

<listitem>
<para><classname>Output</classname> - Lets the file task see the request
queue of the output task, so it can make output requests.</para>
</listitem>
</itemizedlist>

Visibility is provided to the standard library package via a
<command>use</command> clause; references to items declared in the
<classname>Output</classname> package must be fully qualified.

<src:fragment id="file-pkg-body">
with
   Ada.Strings.Unbounded,
   Output;

use
   Ada.Strings.Unbounded;

package body File is
<src:fragref linkend="file-task-body"/>
end File;
</src:fragment>
</para>
</section>

<section>
<title>File Package Spec</title>

<para>The file request queue and its supporting types are declared in the
package spec so they can be used by other packages.</para>

<section>
<title>File Package Spec Basic Type Declarations</title>
<para>
The spec declares the file-queue request record type and its supporting
operation type.  In &prog;, if the operation field is
<literal>File_Operation</literal>, the data field is a file access request; in
&prog;, it's any arbitrary text.  The <literal>Unbounded_String</literal> type
of the <literal>Data</literal> field is defined via <link
linkend="file-pkg-spec-context-section">the context clause</link>.

<src:fragment id="file-basic-types">
   type Operation_Type is ( Shutdown_Operation, File_Operation );

   type Request_Rec is record
      Operation:    Operation_Type;
      Destination:  Unbounded_String;
      Data:         Unbounded_String;
   end record;

   task File_Task;
</src:fragment>
</para>
</section>

<section>
<title>File Queue Declaration</title>
<para>
The spec instatiates the generic library package <literal>PQueue</literal>
using <literal>Request_Rec</literal> as its data-item type, and then declares
the actual file queue itself, as an item of that new queue type.

<src:fragment id="file-queue-decl">
   package File_Queue_Pkg is new PQueue (Request_Rec);

   Requests:  File_Queue_Pkg.Protected_Queue_Type;
</src:fragment></para>
</section>

<section id="file-pkg-spec-context-section">
<title>File Package Spec Context Clause</title>
<para>
The file task's package spec depends on these two packages:

<itemizedlist>
<listitem>
<para><classname>Ada.Strings.Unbounded</classname>, which provides the
<literal>Unbounded_String</literal> type used for the request record's data.
</para>
</listitem>

<listitem>
<para><classname>PQueue</classname>, a local library package, which is not
defined in this document.  It is a generic package which implements a simple
protected queue type.  The code was adapted from Cohen's book <citetitle
pubwork="book">Ada as a Second Language</citetitle>.</para>
</listitem>
</itemizedlist>

Visibility is provided to the standard library package via a
<command>use</command> clause; references to items declared in the
<classname>PQueue</classname> package (whose instantiation is called
<literal>File_Queue_Pkg</literal>) must be fully qualified.

<src:fragment id="file-pkg-spec-context">
with
   Ada.Strings.Unbounded,
   PQueue;

use
   Ada.Strings.Unbounded;
</src:fragment>
</para>
</section>

<section>
<title>Package Spec Proper</title>
<para>

The package spec puts together the context clause and the declarations to make
a compilation unit.

<src:fragment id="file-pkg-spec">
<src:fragref linkend="file-pkg-spec-context"/>

package File is

<src:fragref linkend="file-basic-types"/>

<src:fragref linkend="file-queue-decl"/>

end File;
</src:fragment>
</para>
</section>

</section>
</section>
</section>

</article>
