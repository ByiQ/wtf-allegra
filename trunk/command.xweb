<?xml version="1.0" standalone="no"?>
<!DOCTYPE xweb PUBLIC "-//NDW-WMR//DTD DocBook XML V4.1.2-based Extension XWeb V1.0//EN"
                      "file:///opt/litprog/dtd/xweb.dtd" [
<!ENTITY % entities SYSTEM "entities.inc.dtd">
%entities;
<!ENTITY pkg      "&cmdname;">
]>

<article xmlns:src="http://nwalsh.com/xmlns/litprog/fragment"
         xmlns:xsl="http://www.w3.org/1999/XSL/Transform">



<!-- Article meta-data -->
<articleinfo>
<title>&prog; Command Processor</title>

<author>
<firstname>Chip</firstname>
<surname>Richards</surname>
</author>

<address><email>chipr@niestu.com</email></address>
<publisher>
<publishername>NiEstu</publishername>
<address><otheraddr><ulink url="&site;/allegra/"></ulink></otheraddr></address>
</publisher>

<releaseinfo>Version 1.0</releaseinfo>
<date>30 December 2003</date>

<legalnotice>
<para>This code is released under the terms of the <ulink
url="http://www.gnu.org/licenses/gpl.html">GNU General Public License</ulink>,
version 2.</para>
</legalnotice>
</articleinfo>


<!-- The Command task -->
<section id="command-task">
<title>The Command Task</title>

<para>The command task is the brains of the program.  It interprets input
commands and dispatches requests for information to the database and file
access tasks, as well as handling some commands itself.  In &prog;, the input
comes from the user on the standard input stream; in &prog;, commands come
from users on the IRC server.</para>

<section>
<title>Command Loop</title>
<para>
The heart of the command task is an endless loop.  It removes a request from
the command queue, parses its content as a command, then executes the command.
<link linkend="cmd-set">The command set</link> for &prog; is very simple,
consisting of an initial letter that determines where the remaining data in
the string is to be dispatched.  In addition, it recognizes a
<quote>quit</quote> command, causing it to send shutdown operations to its
subordinate tasks, manually abort the ping and input tasks, and then terminate
its loop, and thus its task, causing the termination of the application
process.

<src:fragment id="command-loop">
      loop
         Requests.Dequeue (Request);
<src:fragref linkend="command-parse"/>
<src:fragref linkend="command-execute"/>
      end loop;
</src:fragment>

The task spends most of its time sitting on the
<methodname>Dequeue</methodname> statement, waiting for a command request to
be placed in its queue by one of the other tasks.  (In &prog;, only <link
linkend="input-task">the input task</link> puts requests on the command
queue.)
</para>

<section>
<title>Command Parsing</title>

<section>
<title>Recognizing Commands</title>

<para>&prog;'s commands come in IRC messages, either sent in the channel, or
as direct private messages.  To begin with, channel messages are only passed
to the &pkg; task by the &inname; task if they contain the program's nick.
Private messages are always passed.  If the nick occurs at the start of the
message, and is followed by one of several separator characters, then the rest
of the message is taken as a command.  Private messages are always assumed to
be commands, though they are allowed (but not required) to have the same
leading-nick syntax as channel messages.</para>

<para>Passed channel messages which don't match the required command syntax
will trigger a quip if that option is enabled in the configuration.</para>
</section>


<section>
<title>Check For Leading-Nick Format</title>

<para>This function checks for the leading-nick message format, and returns
true if the input message matches that format.</para>

<src:fragment id="func-leadnick">
function Leading_Nick (Msg : in string;   Nick:  in string) return boolean is
begin  -- Leading_Nick
   if Msg'Length &gt; Nick'Length + 1 then
      if Index (To_Lower (Msg), Nick) = 1 and Is_In (Msg (Nick'Length + 1), Separators) then
         return true;
      end if;
   end if;
   return false;
end Leading_Nick;
</src:fragment>
</section>

<section>
<function>Command Request Handling</function>
<para>
Since <link linkend="cmd-set">the commands</link> have a very simple format,
parsing them is straightforward.  The parser scans for the first non-blank
character, then interprets that as a command.  (If no non-blank character is
found, the request is discarded.)  The parser then scans for the next
non-blank after the command letter, and uses the rest of the string starting
with that character as the data, if the command requires data.  If there isn't
a non-blank character after the command character, then the data is set to the
null string.

<src:fragment id="command-parse">
         case Request.Operation is
            when Login_Operation =&gt;
               Command := Cmd_Login;

            when Ping_Operation =&gt;
               Output_Request.Operation := &outname;.Ping_Operation;
               Output_Request.Data      := Request.Data;
               Destination := Request.Origin.Nick;
               Command := Cmd_Pong;

            when Message_Operation =&gt;
               declare
                  Comment:  string := To_String (Request.Data);
                  Nick:  string := To_Lower (Config.Get_Value (Config.Item_Nick));
                  type Message_Type is ( PrivMsg, ChanMsg );
                  MsgFor:  Message_Type;
               begin
                  IsCommand := false;
                  if To_Lower (To_String (Request.Target)) = Nick then
                     MsgFor := PrivMsg;
                     Destination := Request.Origin.Nick;
                     IsCommand := true;
                  else
                     MsgFor := ChanMsg;
                     Destination := Request.Target;
                  end if;
                  if Leading_Nick (Comment, Nick) then
                     IsCommand := MsgFor = ChanMsg;
                  end if;

                  if IsCommand then
                     declare
                        CmdStr : string := Trim (Comment (Nick'Length + 2 .. Comment'Length), Side => Ada.Strings.Both);
                     begin
                        if Index (CmdStr, "quit") = 1 then
                           Command := Cmd_Quit;
                        else
                           Output_Request.Data := To_Unbounded_String (CmdStr);
                           Command := Cmd_Process;
                        end if;
                     end;
                  else
                     Command := Cmd_None;
                  end if;
               end;

            when Reply_Operation =&gt;
               Command := Cmd_None;
         end case;
</src:fragment>
</para>

<para>The <methodname>Index_Non_Blank</methodname> function returns the
character position of the first character within its unbounded-string argument
that is not a space character; its operation, and those of the other
unbounded-string functions used in this code, are described in <ulink
url="http://www.adapower.com/rm95/arm95_228.html#SEC228">the Ada Reference
Manual, section A.4.5</ulink>.  If no non-blank character is present, the
function returns zero.</para>

<para>The <methodname>Element</methodname> function is used to fetch the
command character from the unbounded <literal>Data</literal> string, once its
position has been determined.</para>

<para>The test <literal>Cmd_At &lt; Length (Request.Data)</literal>
determines whether any data string follows the command character.  If it is
false, no data was given, and the data string is set to the constant
<literal>Null_Unbounded_String</literal>, causing the eventual user, the
output task, to print nothing.</para>

<para>Once the command character has been found, the
<methodname>Slice</methodname> function is used to return the remainder of the
string, so it can be scanned for the next non-blank character, which is taken
as the first character of actual data.  The
<methodname>To_Unbounded_String</methodname> function must be used, since
<methodname>Slice</methodname> returns a plain fixed-length string value.
This <quote>tail</quote> of the input line is stored temporarily back in the
variable <literal>Data</literal>.</para>

<para><methodname>Slice</methodname> is used once again when (if) a
non-blank character is found following the command character, to extract the
actual data string starting with its first non-blank character.  It is again
converted to an unbounded string and stored back in
<literal>Data</literal>.</para>
</section>

</section>

<section>
<title>Command Execution</title>

<para>
The command having been parsed into the <literal>Command</literal> and
<literal>Data</literal> variables, the command task now attempts to recognize
and execute the command.  The <command>case</command> statement that
recognizes the command has four types of alternative.

<itemizedlist>
<listitem>
<para>The first alternative is the <quote>internal command</quote> handler.
In this simulator, all that does is prepend the string
<quote><literal>Internal command:</literal> </quote> to the input string and
place it on the output queue.</para>
</listitem>

<listitem>
<para>The next two alternatives are <quote>dispatch</quote> commands.
Their commands send a data string to the database access task or the file
access task.</para>
</listitem>

<listitem>
<para>The fourth alternative processes the <quote>quit</quote> command.  It
dispatches shutdown messages to those subordinate tasks which have request
queues, aborts the input and ping tasks (which do not have request queues),
and then terminates itself.  This causes the application to exit.</para>
</listitem>

<listitem>
<para>The final alternative handles all unrecognized commands, by adding an
error message to the output queue.</para>
</listitem>
</itemizedlist>

<src:fragment id="command-execute">
         case Command is

            when Cmd_Login =&gt;
               Info (Command_Name, "Login as " &amp; &cfgname;.Get_Value (&cfgname;.Item_Nick) &amp; " to " &amp;
                                   "#" &amp; &cfgname;.Get_Value (&cfgname;.Item_Channel));
               Output_Request.Operation := &outname;.Nick_Operation;
               Output_Request.Data      := To_Unbounded_String (&cfgname;.Get_Value (&cfgname;.Item_Nick));
               &outname;.Requests.Enqueue (Output_Request);
               Output_Request.Operation := &outname;.User_Operation;
               Output_Request.Data      := To_Unbounded_String (&cfgname;.Get_Value (&cfgname;.Item_UserName) &amp; " 0 * :" &amp; &cfgname;.Get_Value (&cfgname;.Item_RealName));
               &outname;.Requests.Enqueue (Output_Request);
               delay 2.0;  -- doesn't delay the write, but ...
               Output_Request.Operation := &outname;.Join_Operation;
               Output_Request.Data      := To_Unbounded_String ("#" &amp; &cfgname;.Get_Value (&cfgname;.Item_Channel));
               &outname;.Requests.Enqueue (Output_Request);

            when Cmd_Pong =&gt;
               Dbg (Command_Name, "Pong to " &amp; To_String (Destination));
               Output_Request.Destination := Destination;
               &outname;.Requests.Enqueue (Output_Request);

            when Cmd_Process =&gt;
               Dbg (Command_Name, "Processing command " &amp; To_String (Output_Request.Data));
               Output_Request.Operation := Output.Message_Operation;
               Output_Request.Destination := Destination;
               Output_Request.Data := To_Unbounded_String ("That command isn't implemented yet.");
               &outname;.Requests.Enqueue (Output_Request);

            when Cmd_Quit =&gt;
               if Auth.Permitted (Request.Origin, &cfgname;.Cmd_Quit) then
                  Info (Command_Name, "Executing shutdown request from " &amp; To_String (Request.Origin.Nick));
                  Database_Request.Operation := Database.Shutdown_Operation;
                  File_Request.Operation     := File.Shutdown_Operation;
                  Output_Request.Operation   := &outname;.Shutdown_Operation;
                  Database.Requests.Enqueue (Database_Request);
                  File.Requests.Enqueue     (File_Request);
                  Output.Requests.Enqueue   (Output_Request);
                  abort Input.Input_Task;
                  abort Ping.Ping_Task;
                  delay 3.0;
                  &logname;.WrapUp;
                  exit;
               else
                  Info (Command_Name, "Rejecting shutdown request from " &amp; To_String (Request.Origin.Nick));
                  Output_Request.Operation := Output.Message_Operation;
                  Output_Request.Destination := Destination;
                  Output_Request.Data := To_Unbounded_String ("I'm sorry, I don't know you well enough to take orders from you.");
                  &outname;.Requests.Enqueue (Output_Request);
               end if;

            when Cmd_None =&gt;
               null;
         end case;
</src:fragment>

</para>

<para>It may be argued that it would be <quote>cleaner</quote> in some ways
for the input and ping tasks to have their own <quote>back-channel</quote>
queues, to accept the shutdown command at the very least, if not other as yet
unforeseen command operations, instead of having the command task forcibly
<quote>shoot them in the head</quote> as it does now.  However, monitoring
both that queue and their primary input source (the IRC socket, in the case of
the input task, and the clock in the ping task) would complicate the logic,
and seems a high price to pay for something that can be solved in this fairly
straightforward manner using standard Ada facilities.  Suggestions are
welcome, however.</para>

</section>
</section>

<section>
<title>Command Task Declarations</title>

<para>
The command loop uses these variables:

<itemizedlist>
<listitem>
<para><literal>Request</literal> - A local item of the type of the
command-queue entries, used to receive the next item taken from the request
queue.  It has only one field, <literal>Data</literal>, which contains the
command string to be parsed.</para>
</listitem>

<listitem>
<para><literal>Database_Request</literal>, <literal>File_Request</literal>,
and <literal>Output_Request</literal> - Request-queue variables for each of
the three subordinate tasks that the command task talks to.  Used by the
command execution code to build requests to send to other tasks.</para>
</listitem>

<listitem>
<para><literal>Cmd_At</literal> and <literal>Data_At</literal> - Indices
within the command string of the location of the command character and the
start of the data, respectively.  Used by the parser to locate the separate
pieces of the command.</para>
</listitem>

<listitem>
<para><literal>Command</literal> - The command letter, set by the parser
and used by the execution code to determing which action to take.</para>
</listitem>

<listitem>
<para><literal>Data</literal> - The data portion of the command string, set
by the parser and used by the execution code when building an outgoing
request.</para>
</listitem>
</itemizedlist>

<src:fragment id="command-decls">
      Separators:  Character_Set := To_Set (",:~");

      Request:           Request_Rec;
      Database_Request:  Database.Request_Rec;
      File_Request:      File.Request_Rec;
      Output_Request:    &outname;.Request_Rec;
      Comment:           Unbounded_String;
      Destination:       Unbounded_String;
      Command:           Command_Type;
      IsCommand:         boolean;

<src:fragref linkend="func-leadnick"/>
</src:fragment>

</para>
</section>

<section>
<title>Command Task Body</title>
<para>
The task's body contains only the processing loop, and its required
declarations:

<src:fragment id="command-task-body">

   task body Command_Task is
<src:fragref linkend="command-decls"/>

   begin  -- Command_Task
<src:fragref linkend="command-loop"/>

   exception
      when E: others =>
         Err (Command_Name, "Exception:  " &amp; Ada.Exceptions.Exception_Information (E));
   end Command_Task;

</src:fragment>
</para>
</section>

<section>
<title>Command Task Package</title>

<section>
<title>Command Package Body</title>
<para>
For compilation purposes, the task is contained in a package.  The package
body contains only the (anonymous) task object.  The external dependencies
are:

<itemizedlist>
<listitem>
<para><classname>Ada.Strings.Unbounded</classname> - Provides several
functions, and one constant, used by the command processor during recognition
and execution of the commands.</para>
</listitem>

<listitem>
<para><classname>Database</classname>, <classname>File</classname>, and
<classname>&outname;</classname> - Lets the command task see the request queues
of these other tasks, and place requests on them.</para>
</listitem>

<listitem>
<para><classname>Input</classname> and <classname>Ping</classname> - Lets
the command task see these task objects so they can be aborted when the
program terminates.</para>
</listitem>
</itemizedlist>

Visibility is provided to the standard library package via a
<command>use</command> clause; references to items declared in the local
packages must be fully qualified.

<src:fragment id="command-pkg-body">
with
   Ada.Characters.Handling,
   Ada.Exceptions,
   Ada.Strings.Fixed,
   Ada.Strings.Maps,
   Ada.Strings.Unbounded,
   &authname;,
   &cfgname;,
   &dataname;,
   &filename;,
   &inname;,
   &logname;,
   &outname;,
   &pingname;;

use
   Ada.Characters.Handling,
   Ada.Strings.Fixed,
   Ada.Strings.Maps,
   Ada.Strings.Unbounded,
   &logname;;

package body Command is
<src:fragref linkend="command-task-body"/>
end Command;
</src:fragment>
</para>
</section>

<section>
<title>Command Package Spec</title>

<para>The command request queue and its supporting types are declared in the
package spec so they can be used by other packages.</para>

<section>
<title>Command Package Spec Basic Type Declarations</title>
<para>
The spec declares the command-queue request record type and its supporting
operation type.  The command request record contains only a data string (the
<literal>Data</literal> field).  The data is the command as issued by the
user.  The <literal>Unbounded_String</literal>type of the
<literal>Data</literal> field is defined via <link
linkend="command-pkg-spec-context-section">the context clause</link>.  The
spec also declares the task which comprises the body of the package.

<src:fragment id="command-basic-types">
   type Operation_Type is ( Login_Operation, Reply_Operation, Message_Operation, Ping_Operation );

   subtype Reply_Type is string ( 1 .. 3 );

   type Request_Rec is record
      Operation:  Operation_Type;
      Origin:     &ircname;.MsgTo_Rec;
      Target:     Unbounded_String;
      Data:       Unbounded_String;
      Reply:      Reply_Type;
   end record;

   type Command_Type is ( Cmd_None, Cmd_Login, Cmd_Pong, Cmd_Process, Cmd_Quit );

   task Command_Task;
</src:fragment>
</para>
</section>

<section>
<title>Command Queue Declaration</title>
<para>
The spec instatiates the generic library package <literal>PQueue</literal>
using <literal>Request_Rec</literal> as its data-item type, and then declares
the actual command queue itself, as an item of that new queue type.

<src:fragment id="command-queue-decl">
   package Command_Queue_Pkg is new PQueue (Request_Rec);

   Requests:  Command_Queue_Pkg.Protected_Queue_Type;
</src:fragment></para>
</section>

<section id="command-pkg-spec-context-section">
<title>Command Package Spec Context Clause</title>
<para>
The command task's package spec depends on these two packages:

<itemizedlist>
<listitem>
<para><classname>Ada.Strings.Unbounded</classname>, which provides the
<literal>Unbounded_String</literal> type used for the request record's data.
</para>
</listitem>

<listitem>
<para><classname>PQueue</classname>, a local library package, which is not
defined in this document.  It is a generic package which implements a simple
protected queue type.  The code was adapted from Cohen's book <citetitle
pubwork="book">Ada as a Second Language</citetitle>.</para>
</listitem>
</itemizedlist>

Visibility is provided to the standard library package via a
<command>use</command> clause; references to items declared in the
<classname>PQueue</classname> package (whose instantiation is called
<literal>Command_Queue_Pkg</literal>) must be fully qualified.

<src:fragment id="command-pkg-spec-context">
with
   Ada.Strings.Unbounded,
   PQueue,
   &ircname;;

use
   Ada.Strings.Unbounded;
</src:fragment>
</para>
</section>

<section>
<title>Package Spec Proper</title>
<para>

The package spec puts together the context clause and the declarations to make
a compilation unit.

<src:fragment id="command-pkg-spec">
<src:fragref linkend="command-pkg-spec-context"/>

package Command is

   &pkg;_Name:  constant string := "&pkg;";

<src:fragref linkend="command-basic-types"/>

<src:fragref linkend="command-queue-decl"/>
end Command;
</src:fragment>
</para>
</section>

</section>
</section>
</section>


</article>
