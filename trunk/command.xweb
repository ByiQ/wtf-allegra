<?xml version="1.0" standalone="no"?>
<!DOCTYPE xweb PUBLIC "-//NDW-WMR//DTD DocBook XML V4.1.2-based Extension XWeb V1.0//EN"
                      "file:///opt/litprog/dtd/xweb.dtd" [
<!ENTITY % entities SYSTEM "entities.inc.dtd">
%entities;
<!ENTITY pkg      "&cmdname;">
]>

<article xmlns:src="http://nwalsh.com/xmlns/litprog/fragment"
         xmlns:xsl="http://www.w3.org/1999/XSL/Transform">



<!-- Article meta-data -->
<articleinfo>
<title>&prog; Command Processor</title>

<author>
<firstname>Chip</firstname>
<surname>Richards</surname>
</author>

<address><email>chipr@niestu.com</email></address>
<publisher>
<publishername>NiEstu</publishername>
<address><otheraddr><ulink url="&site;/allegra/"></ulink></otheraddr></address>
</publisher>

<releaseinfo>Version 1.0</releaseinfo>
<date>30 December 2003</date>

<legalnotice>
<para>This code is released under the terms of the <ulink
url="http://www.gnu.org/licenses/gpl.html">GNU General Public License</ulink>,
version 2.</para>
</legalnotice>
</articleinfo>


<!-- The Command task -->
<section id="command-task">
<title>The Command Task</title>

<para>The command task is the brains of the program.  It interprets input
commands and dispatches requests for information to the database and file
access tasks, as well as handling some commands itself.  In &prog;, commands
come from users on the IRC server.</para>

<section>
<title>Command Loop</title>
<para>
The heart of the command task is an endless loop.  It removes a request from
the command queue, parses its content as a command, then executes the command.
<link linkend="cmd-set">The command set</link> for &prog; is fairly simple,
and owes much of its design to David Sobon's blootbot, which in turn was based
on infobot by Kevin Lenzo and Patrick Cole.

<src:fragment id="command-loop">
   loop
      Requests.Dequeue (Request);
      <src:fragref linkend="process-request"/>
   end loop;
</src:fragment>

The task spends most of its time sitting on the
<methodname>Dequeue</methodname> statement, waiting for a command request to
be placed in its queue by one of the other tasks.  (In &prog;, only <link
linkend="&inpkg;">the input task</link> puts command requests on the
command queue, though any task can send a <quote>crash</quote> request.)
</para>


<!-- Command Recognition -->
<section>
<title>Recognizing Command Messages</title>
<para>The &pkg; task receives requests for several types of operations.  Most
of these operations have fixed actions.  Only messages require additional
action, which is to inspect them to determine if they contain user
commands.</para>

<para>&prog;'s user commands come in IRC messages, either sent in the channel,
or as direct private messages.  Channel messages are only passed to the &pkg;
task by the &inname; task if they contain the program's nick, or if they begin
with the shorthand string (if it is configured).  Private messages are always
passed.  So we begin with the assumption that all message requests we receive
are worthy of the command processor's attention.</para>

<section>
<title>Prefix Scanning</title>
<para>Both channel messages and private messages may begin with either the
shorthand string, or the program's nick followed by one of several separator
characters.  This prefix is required for a channel message to be recognized as
a command, but for consistency is allowed on private messages too.  If it's
present, its presence is noted, and it is stripped; if not, we use the entire
message as the actual command string.  If shorthand recognition is enabled, we
look for that first.  Note that with the leading-nick form, the actual command
begins one position past the separator character (My_Nick'Length + 2).

<src:fragment id="prefix-scan">
   Has_Prefix := false;
   Command := US (Message);
   if Shorthand'Length &gt; 0 and then Index (Message, Shorthand) = 1 then
      Has_Prefix := true;
      Command := US (Message (Shorthand'Length + 1 .. Message'Length));
   elsif Leading_Nick (Message, My_Nick) then
      Has_Prefix := true;
      Command := US (Message (My_Nick'Length + 2 .. Message'Length));
   end if;
   Command := Trim (Command, Side => Ada.Strings.Both);
</src:fragment>
</para>
</section>

<section>
<title>Command Recognition</title>
<para>Recognition continues by assuming that the message is
<emphasis>not</emphasis> a command, until it is proven to be one.  It then
determines whether we have a private message or a channel message by checking
the message's target.  Private messages are always assumed to be commands.
Channel messages are commands only if they have a recognized prefix.  In
both cases, we set the message type and destination, which determine how the
response is constructed.

<src:fragment id="recognize">
   Is_Command := false;
   if To_Lower (S (Request.Target)) = My_Nick then
      Is_Command := true;
      Msg_Type := PrivMsg;
      Destination := Sender.Nick;
   else
      Is_Command := Has_Prefix;
      Msg_Type := ChanMsg;
      Destination := Request.Target;
   end if;
</src:fragment>
</para>
</section>

<section>
<title>Check For Leading-Nick Prefix</title>

<para>This function checks for the leading-nick message prefix, and returns
true if the input message has one, false if not.  We ensure that the message
contains at least one character after the separator, by checking for
<literal>Nick'Length + 2</literal>.</para>

<src:fragment id="func-leadnick">
   function Leading_Nick (Msg : in string;   Nick:  in string) return boolean is
   begin  -- Leading_Nick
      if Msg'Length &gt; Nick'Length + 2 then
         if Index (To_Lower (Msg), Nick) = 1 and Is_In (Msg (Nick'Length + 1), Separators) then
            return true;
         end if;
      end if;
      return false;
   end Leading_Nick;
</src:fragment>
</section>

</section>


<!-- Request processing -->
<section>
<title>Request Processing</title>
<para>The task handles incoming requests by selecting the processing they
require, based on the request's operation type.  The operations are:

<itemizedlist>
<listitem>
<para><literal>Crash_Operation</literal> - Received when another task has
suffered an unhandled exception.  The request's <varname>Data</varname> field
contains the name of the task which crased, to be logged if desired.</para>
</listitem>

<listitem>
<para><literal>Login_Operation</literal> - Received at program startup, and
after a reconnect, to ask the program to log in to the IRC server and join its
configured channel.  The request contains no additional data.</para>
</listitem>

<listitem>
<para><literal>Message_Operation</literal> - Received when the &inname; task
sees something that might be a user command.  That is, a private message
addressed to &prog;, or a channel message containing the program's nick.  The
request's <varname>Origin</varname> field contains the sender's user ID, in
IRC <quote>msgto</quote> format; the <varname>Target</varname> field contains
the message's target (either a nick or a channel name), and the
<varname>Data</varname> field contains the text of the message.</para>
</listitem>

<listitem>
<para><literal>Ping_Operation</literal> - Received when a ping message comes
from the server, or when the &pingname; task gets lonely.  The request's
<varname>Data</varname> field contains the ping message's parameter.</para>
</listitem>

<listitem>
<para><literal>Reply_Operation</literal> - Received when a numeric IRC reply
comes in from the server.  These can be error messages, status messages, or
several other sorts.  Currently, the command task ignores them, but in the
future, they will be used for several purposes, including better handling of
nick collisions, login failures, user tracking perhaps, etc.  The request's
<varname>Reply</varname> field contains the three-digit numeric reply code,
and the <varname>Data</varname> field contains the reply's parameter(s).</para>
</listitem>
</itemizedlist>

<src:fragment id="process-request">
   case Request.Operation is

      when Login_Operation =&gt;
         Info (Command_Name, "Begin login as " &amp; &cfgname;.Get_Value (&cfgname;.Item_Nick));
         Output_Request.Operation := &outname;.Nick_Operation;
         Output_Request.Data      := US (&cfgname;.Get_Value (&cfgname;.Item_Nick));
         &outname;.Requests.Enqueue (Output_Request);
         Output_Request.Operation := &outname;.User_Operation;

         delay 3.0;  -- let the server respond a bit; required for pircd, at least
         Request.Operation := Finish_Login_Operation;
         Requests.Enqueue (Request);

      when Finish_Login_Operation =&gt;
         Info (Command_Name, "Finish login to " &amp; "#" &amp; &cfgname;.Get_Value (&cfgname;.Item_Channel));
         Output_Request.Operation := &outname;.User_Operation;
         Output_Request.Data      := US (&cfgname;.Get_Value (&cfgname;.Item_UserName) &amp;
                                                          " 0 * :" &amp; &cfgname;.Get_Value (&cfgname;.Item_RealName));
         &outname;.Requests.Enqueue (Output_Request);
         delay 3.0;  -- doesn't delay the write, but ...
         Output_Request.Operation := &outname;.Join_Operation;
         Output_Request.Data      := US ("#" &amp; &cfgname;.Get_Value (&cfgname;.Item_Channel));
         &outname;.Requests.Enqueue (Output_Request);
         Say ("identify nulet0", "nickserv");  -- quick hack for development

      when Ping_Operation =&gt;
         Dbg (Command_Name, "Ping with " &amp; S (Request.Data));
         Output_Request.Operation := &outname;.Ping_Operation;
         Output_Request.Data      := Request.Data;
         &outname;.Requests.Enqueue (Output_Request);

      when Pong_Operation =&gt;
         Dbg (Command_Name, "Pong with " &amp; S (Request.Data));
         Output_Request.Operation := &outname;.Pong_Operation;
         Output_Request.Data      := Request.Data;
         &outname;.Requests.Enqueue (Output_Request);

      when Message_Operation =&gt;
         declare
            Command    : Unbounded_String;
            Has_Prefix : boolean;
            Is_Command : boolean;
            Message    : string := S (Request.Data);
            My_Nick    : string := To_Lower (&cfgname;.Get_Value (Config.Item_Nick));
            Shorthand  : string := &cfgname;.Get_Value (&cfgname;.Item_Shorthand);
         begin
            &ircname;.Parse_MsgTo (Request.Origin, Sender);
            <src:fragref linkend="prefix-scan"/>
            <src:fragref linkend="recognize"/>
            if Is_Command then
               Do_Exit := false;
               Process_Command (S (Command), Sender);
               exit when Do_Exit;
            elsif &cfgname;.Get_Value (&cfgname;.Item_Quips) = "on" then
               Database_Request.Operation := &dataname;.Quip_Operation;
               Database_Request.Destination := Destination;
               &dataname;.Requests.Enqueue (Database_Request);
            end if;
         end;

      when Crash_Operation =&gt;
         Err (Command_Name, "Crashed:  " &amp; S (Request.Data));
         Do_Crash;
         exit;

      when Reply_Operation =&gt;
         null;  -- for now
   end case;
</src:fragment>
</para>

<para>It may be argued that it would be <quote>cleaner</quote> in some ways
for the input and ping tasks to have their own <quote>back-channel</quote>
queues, to accept the shutdown command at the very least, if not other as yet
unforeseen command operations, instead of having the command task forcibly
<quote>shoot them in the head</quote> as it does now.  However, monitoring
both that queue and their primary input source (the IRC socket, in the case of
the input task, and the clock in the ping task) would complicate the logic,
and seems a high price to pay for something that can be solved in this fairly
straightforward manner using standard Ada facilities.  Suggestions are
welcome, however.</para>

<section>
<title>Program Shutdown</title>

<para>This procedure causes the program to close up shop.  It sends shutdown
requests to the tasks which accept them, and aborts the tasks which don't,
waits a bit for the whole thing to settle down (which should eventually be
replaced by a wait for the appropriate server reply code in response to the
logout request), then closes the log.  It is called when it accepts a
<quote>quit</quote> command, or when this or another task crashes.</para>

<para>Note that no shutdown request is sent to the &outname; task.  That's
because its shutdown operation is initiated by the &dataname; task, due to the
desire to have a random <quote>quit</quote> message, drawn from a
configuration database table.

<src:fragment id="proc-shutdown">
   procedure Shutdown is
   begin  -- Shutdown
      Database_Request.Operation := &dataname;.Shutdown_Operation;
      File_Request.Operation     := &filename;.Shutdown_Operation;
      &dataname;.Requests.Enqueue (Database_Request);
      &filename;.Requests.Enqueue (File_Request);
      abort &inname;.Input_Task;
      abort &pingname;.Ping_Task;
      delay 3.0;
      &logname;.WrapUp;
   end Shutdown;
</src:fragment>
</para>
</section>

</section>

</section>


<!-- Command parsing -->
<section>
<title>Command Parsing</title>

<para>

<src:fragment id="proc-process-cmd">
   procedure Process_Command (Cmd:  in string;   Sender:  in &ircname;.MsgTo_Rec) is

   <src:fragref linkend="proc-exec"/>

   begin  -- Process_Command
      Dbg (Command_Name, "Processing command """ &amp; Cmd &amp; """ from " &amp; S (Sender.Nick));
      if Match (Pat_Fetch2.all, Cmd) = Cmd'First then
         Exec (&cfgname;.Cmd_Fetch, Fetch'Access);
         return;
      end if;
      for CmdType in Command_Table'Range loop
         if Match (Command_Table (CmdType).Matcher.all, Cmd) = Cmd'First then
            Exec (CmdType, Command_Table (CmdType).Process);
            return;
         end if;
      end loop;
      Unrecognized (Cmd, Sender);
   end Process_Command;
</src:fragment>
</para>

<section>
<title>Executing Commands</title>
<para>

<src:fragment id="proc-exec">
   procedure Exec (CmdType : in &cfgname;.Command_Type;   Proc : in Command_Processor) is

      use &authname;;

      Authorized : Authorization;

   begin  -- Exec
      Authorized := Permitted (Request.Origin, CmdType);
      if Authorized = Succeeded then
         Proc (Cmd, Sender);
      else
         Info (Command_Name, "Rejecting command """ &amp; Cmd &amp; """ from " &amp; S (Request.Origin) &amp; " because " &amp;
               Authorization'Image (Authorized));
         Say ("I'm sorry " &amp; S (Sender.Nick) &amp;
              ", I don't know you well enough to take orders from you.",
              S (Destination));
      end if;
   end Exec;
</src:fragment>
</para>
</section>

<section>
<title>The Access (Set Auth Level) Command</title>
<para>

<src:fragment id="cmd-access">
   procedure SetAuth (Cmd     : in string;
                      Sender  : in &ircname;.MsgTo_Rec) is

      Matches : Match_Array (Match_Range);

   begin  -- SetAuth
      Match (Command_Table (&cfgname;.Cmd_Access).Matcher.all, Cmd, Matches);
      if Matches (2) = No_Match or Matches (3) = No_Match then
         Say ("That may be your idea of an access command, but it isn't mine ... try again, maybe?", S (Destination));
         return;
      end if;
      declare
         Nick  : string := Cmd (Matches (2).First .. Matches (2).Last);
         Level : string := Cmd (Matches (3).First .. Matches (3).Last);
      begin
         if To_Lower (Nick) = To_Lower (&cfgname;.Get_Value (Config.Item_Nick)) then
            Say ("I am already the Lord of Access, O mortal!", S (Destination));
            return;
         end if;
         Database_Request.Operation := &dataname;.Access_Operation;
         Database_Request.Origin    := Sender.Nick;
         Database_Request.Key       := US (Nick);
         Database_Request.Data      := US (Level);
         &dataname;.Requests.Enqueue (Database_Request);
      end;
   end SetAuth;
</src:fragment>
</para>
</section>

<section>
<title>The Fetch Command</title>
<para>

<src:fragment id="cmd-fetch">
   procedure Fetch  (Cmd     : in string;
                     Sender  : in &ircname;.MsgTo_Rec) is

      Fact    : Unbounded_String;
      Matches : Match_Array (Match_Range);

   begin  -- Fetch
      Fact := Null_Unbounded_String;
      if Match (Pat_Fetch2.all, Cmd) = Cmd'First then
         Match (Pat_Fetch2.all, Cmd, Matches);
         if    Matches (3) /= No_Match then
            Fact := US (Cmd (Matches (3).First .. Matches (3).Last));
         elsif Matches (2) /= No_Match then
            Fact := US (Cmd (Matches (2).First .. Matches (2).Last));
         end if;
      else
         Match (Command_Table (&cfgname;.Cmd_Fetch).Matcher.all, Cmd, Matches);
         if Matches (1) /= No_Match then
            Fact := US (Cmd (Matches (1).First .. Matches (1).Last));
         end if;
      end if;

      if Fact /= Null_Unbounded_String then
         while Length (Fact) &gt; 0 and then (Element (Fact, Length (Fact)) = '?' or Element (Fact, Length (Fact)) = ' ') loop
            Fact := Head (Fact, Length (Fact) - 1);
         end loop;
         if Element (Fact, 1) = '~' then
            Database_Request.Operation := &dataname;.RE_Fetch_Operation;
            Database_Request.Data      := US (Slice (Fact, 2, Length (Fact)));
         else
            Database_Request.Operation := &dataname;.Fetch_Operation;
            Database_Request.Data      := Fact;
         end if;
         Database_Request.Destination := Destination;
         &dataname;.Requests.Enqueue (Database_Request);
      else
         Say ("I can't quite make out your question--try again, maybe?", S (Destination));
      end if;
   end Fetch;
</src:fragment>
</para>
</section>

<section>
<title>The Find Command</title>
<para>

<src:fragment id="cmd-find">
   procedure Find   (Cmd     : in string;
                     Sender  : in &ircname;.MsgTo_Rec) is
   begin  -- Find
      Say ("The find command is not yet implemented.", S (Destination));
   end Find;
</src:fragment>
</para>
</section>

<section>
<title>The Forget Command</title>
<para>

<src:fragment id="cmd-forget">
   procedure Forget (Cmd     : in string;
                     Sender  : in &ircname;.MsgTo_Rec) is
   begin  -- Forget
      Say ("The forget command is not yet implemented.", S (Destination));
   end Forget;
</src:fragment>
</para>
</section>

<section>
<title>The Help Command</title>
<para>

<src:fragment id="cmd-help">
   procedure Help   (Cmd     : in string;
                     Sender  : in &ircname;.MsgTo_Rec) is
   begin  -- Help
      Say ("I currently know the following commands:", S (Destination));
      for Msg in Help_Table'Range loop
         Say ("   " &amp; S (Help_Table (Msg)), S (Destination));
         if Msg /= Help_Table'Last then
            delay 1.0;
         end if;
      end loop;
      Say ("The shortcut string is """ &amp; &cfgname;.Get_Value (&cfgname;.Item_Shorthand) &amp; """", S (Destination));
   end Help;
</src:fragment>
</para>
</section>

<section>
<title>The List Command</title>
<para>

<src:fragment id="cmd-list">
   procedure List   (Cmd     : in string;
                     Sender  : in &ircname;.MsgTo_Rec) is

      Matches : Match_Array (Match_Range);
      Pat     : Unbounded_String;

   begin  -- List
      Match (Command_Table (&cfgname;.Cmd_List).Matcher.all, Cmd, Matches);
      if Matches (2) = No_Match then
         Pat := US (".");
      else
         Pat := US (Trim (Cmd (Matches (2).First .. Matches (2).Last), Side => Ada.Strings.Both));
      end if;
      Database_Request.Operation   := &dataname;.List_Operation;
      Database_Request.Data        := Pat;
      Database_Request.Destination := Destination;
      &dataname;.Requests.Enqueue (Database_Request);
   end List;
</src:fragment>
</para>
</section>

<section>
<title>The Quit Command</title>
<para>

<src:fragment id="cmd-quit">
   procedure Quit   (Cmd     : in string;
                     Sender  : in &ircname;.MsgTo_Rec) is
   begin  -- Quit
      Info (Command_Name, "Executing shutdown request from " &amp; S (Request.Origin));
      Shutdown;
      Do_Exit := true;
   end Quit;
</src:fragment>
</para>
</section>

<section>
<title>The Quote Command</title>
<para>

<src:fragment id="cmd-quote">
   procedure Quote  (Cmd     : in string;
                     Sender  : in &ircname;.MsgTo_Rec) is
   begin  -- Quote
      Database_Request.Operation   := &dataname;.Quote_Operation;
      Database_Request.Destination := Destination;
      &dataname;.Requests.Enqueue (Database_Request);
   end Quote;
</src:fragment>
</para>
</section>

<section>
<title>The Rename Command</title>
<para>

<src:fragment id="cmd-rename">
   procedure Rename (Cmd     : in string;
                     Sender  : in &ircname;.MsgTo_Rec) is
   begin  -- Rename
      Say ("The rename command is not yet implemented.", S (Destination));
   end Rename;
</src:fragment>
</para>
</section>

<section>
<title>The Set Command</title>
<para>

<src:fragment id="cmd-set">
   procedure Set    (Cmd     : in string;
                     Sender  : in &ircname;.MsgTo_Rec) is

      Matches : Match_Array (Match_Range);

   begin  -- Set
      Say ("The set command is not yet implemented.", S (Destination));
      Match (Command_Table (&cfgname;.Cmd_Set).Matcher.all, Cmd, Matches);
      Say ("But if it were, I'd be setting """ &amp; Cmd (Matches (1).First .. Matches (1).Last) &amp; """ to """ &amp;
           Cmd (Matches (3).First .. Matches (3).Last) &amp; """", S (Destination));
   end Set;
</src:fragment>
</para>
</section>

<section>
<title>The Stats Command</title>
<para>

<src:fragment id="cmd-stats">
   procedure Stats  (Cmd     : in string;
                     Sender  : in &ircname;.MsgTo_Rec) is
   begin  -- Stats
      Say ("The stats command is not yet implemented.", S (Destination));
   end Stats;
</src:fragment>
</para>
</section>

<section>
<title>The Tell Command</title>
<para>

<src:fragment id="cmd-tell">
   procedure Tell   (Cmd     : in string;
                     Sender  : in &ircname;.MsgTo_Rec) is

      Matches : Match_Array (Match_Range);

   begin  -- Tell
      Match (Command_Table (&cfgname;.Cmd_Tell).Matcher.all, Cmd, Matches);
      if Matches (2) = No_Match or Matches (4) = No_Match then
         Say ("That doesn't quite make sense to me ... try again, maybe?", S (Destination));
         return;
      end if;
      declare
         To   : string := Cmd (Matches (2).First .. Matches (2).Last);
         Fact : string := Cmd (Matches (4).First .. Matches (4).Last);
      begin
         if To_Lower (To) = To_Lower (&cfgname;.Get_Value (Config.Item_Nick)) then
            Say ("Hey, I already know that!", S (Destination));
            return;
         end if;
         if Fact (Fact'First) = '~' then
            Database_Request.Operation := &dataname;.RE_Tell_Operation;
            Database_Request.Data      := US (Fact (Fact'First + 1 .. Fact'Last));
         else
            Database_Request.Operation := &dataname;.Tell_Operation;
            Database_Request.Data      := US (Fact);
         end if;
         Database_Request.Origin      := Sender.Nick;
         Database_Request.Destination := US (To);
         &dataname;.Requests.Enqueue (Database_Request);
      end;
   end Tell;
</src:fragment>
</para>
</section>

<section>
<title>Unrecognized Command Handling</title>
<para>

<src:fragment id="cmd-unrecognized">
   procedure Unrecognized (Cmd     : in string;
                           Sender  : in &ircname;.MsgTo_Rec) is

      Msg : string := "I don't recognize that command.";

   begin  -- Unrecognized
      if Cmd (1) = '~' then
         Database_Request.Operation := &dataname;.RE_Fetch_Operation;
         Database_Request.Data      := US (Cmd (2 .. Cmd'Last));
      else
         Database_Request.Operation := &dataname;.Fetch_Operation;
         Database_Request.Data      := US (Cmd);
      end if;
      Database_Request.Destination := Destination;
      &dataname;.Requests.Enqueue (Database_Request);
---      if Msg_Type = PrivMsg then
---         Say (Msg, S (Destination));
---      else
---         Say ("Sorry " &amp; S (Sender.Nick) &amp; ", " &amp; Msg, S (Destination));
---      end if;
   end Unrecognized;
</src:fragment>
</para>
</section>

<section>
<title>Parser Initialization</title>
<para>

<src:fragment id="proc-parser-init">
   procedure Parser_Init is

      use &cfgname;;

      procedure Enter (Cmd      : in Command_Type;
                       Pat      : in string;
                       Proc     : in Command_Processor) is
      begin  -- Enter
         Command_Table (Cmd) := (new Pattern_Matcher'(Compile (Pat,  Case_Insensitive)), Proc);
      end Enter;

   begin  -- Parser_Init
      Enter (Cmd_Access, "^(access)\s+(\S+)\s+(\d+)$",                            SetAuth'Access);
      Enter (Cmd_Fetch,  "^(\S.*)\s*(\?)",                                        Fetch'Access);
      Enter (Cmd_Find,   "^(find)\s+(\S.*)$",                                     Find'Access);
      Enter (Cmd_Forget, "^(forget)\s+(\S.*)$",                                   Forget'Access);
      Enter (Cmd_Help,   "^(help)$",                                              Help'Access);
      Enter (Cmd_List,   "^(list)(\s+\S.*)?$",                                    List'Access);
      Enter (Cmd_Quit,   "^(quit)$",                                              Quit'Access);
      Enter (Cmd_Quote,  "^(quote)$",                                             Quote'Access);
      Enter (Cmd_Rename, "^(rename)\s+(\S.*)\s+(as\s+|to\s+)?(\S.*)$",            Rename'Access);
      Enter (Cmd_Set,    "^(\S.*?)\s+(is|are)\s+(\S.*)$",                         Set'Access);
      Enter (Cmd_Stats,  "^(stats)(\s+\S.*)?$",                                   Stats'Access);
      Enter (Cmd_Tell,   "^(tell)\s+(\S+)\s+(about\s+)?(\S.*)$",                  Tell'Access);
      Pat_Fetch2 := new Pattern_Matcher'(Compile ("^(what)\s+(is\s+|are\s+)?(\S.*)$",  Case_Insensitive));
   end Parser_Init;
</src:fragment>
</para>
</section>

<section>
<title>Crash Handling</title>
<para>

<src:fragment id="proc-do-crash">
   procedure Do_Crash is
   begin  -- Do_Crash
      Say ("I'm not feeling well ... think I'll go lie down.", Channel);
      Shutdown;
   end Do_Crash;
</src:fragment>
</para>
</section>

<section>
<title>Say a String</title>
<para>

<src:fragment id="proc-say">
   procedure Say (Msg : in string;  To : in string) is
   begin  -- Say
      Output_Request.Operation := Output.Message_Operation;
      Output_Request.Destination := US (To);
      Output_Request.Data := US (Msg);
      &outname;.Requests.Enqueue (Output_Request);
   end Say;
</src:fragment>
</para>
</section>

<section>
<title>Channel-Name Function</title>
<para>

<src:fragment id="func-channel">
   function Channel return string is
   begin  -- Channel
      return "#" &amp; &cfgname;.Get_Value (&cfgname;.Item_Channel);
   end ;
</src:fragment>
</para>
</section>

</section>


<!-- Task body declarations -->
<section>
<title>Command Task Declarations</title>

<para>
The command loop uses these variables:

<itemizedlist>
<listitem>
<para><literal>Request</literal> - A local item of the type of the
command-queue entries, used to receive the next item taken from the request
queue.</para>
</listitem>

<listitem>
<para><literal>Database_Request</literal>, <literal>File_Request</literal>,
and <literal>Output_Request</literal> - Request-queue variables for each of
the three subordinate tasks that the command task talks to.  Used by the
command execution code to build requests to send to other tasks.</para>
</listitem>
</itemizedlist>

<src:fragment id="command-decls">
   function S (Source : in Ada.Strings.Unbounded.Unbounded_String) return string
     renames Ada.Strings.Unbounded.To_String;

   function US (Source : in string) return Ada.Strings.Unbounded.Unbounded_String
     renames Ada.Strings.Unbounded.To_Unbounded_String;

   Separators  : Character_Set := To_Set (",:~");
   Max_Matches : constant := 4;

   subtype Match_Range is Match_Count range 1 .. Max_Matches;

   type Message_Type_Enm is ( PrivMsg, ChanMsg );

   type Matcher_Ptr is access Pattern_Matcher;
   type Command_Processor is access procedure (Cmd     : in string;
                                               Sender  : in &ircname;.MsgTo_Rec);
   type Command_Descriptor is record
      Matcher  : Matcher_Ptr;
      Process  : Command_Processor;
   end record;

   subtype Valid_Commands is &cfgname;.Command_Type range &cfgname;.Cmd_Access .. &cfgname;.Command_Type'Last;

   Command_Table    : array (Valid_Commands) of Command_Descriptor;
   Database_Request : &dataname;.Request_Rec;
   Destination      : Unbounded_String;
   Do_Exit          : boolean;
   File_Request     : &filename;.Request_Rec;
   Msg_Type         : Message_Type_Enm;
   Output_Request   : &outname;.Request_Rec;
   Pat_Fetch2       : Matcher_Ptr;
   Request          : Request_Rec;
   Sender           : &ircname;.MsgTo_Rec;

   Help_Table : array (positive range &lt;&gt;) of Unbounded_String :=
   (
--      US ("&lt;factoid-name&gt; (is|are) [also|so|too|action|reply] &lt;factoid-def&gt;"),
      US ("[~]&lt;factoid-name&gt;[?]"),
      US ("tell &lt;nick&gt; about &lt;factoid&gt;"),
      US ("what [is|are] [~]&lt;factoid&gt; [?]"),
--      US ("forget &lt;factoid&gt;"),
--      US ("rename &lt;from-name&gt; [as|to] &lt;to-name&gt;"),
--      US ("find &lt;string&gt;"),
      US ("help"),
      US ("list [regexp]"),
      US ("quote"),
--      US ("stats [&lt;factoid&gt;]"),
--      US ("access &lt;mask&gt; &lt;level&gt;"),
      US ("quit")
   );

<src:fragref linkend="func-channel"/>

<src:fragref linkend="proc-say"/>

<src:fragref linkend="func-leadnick"/>

<src:fragref linkend="proc-shutdown"/>

<src:fragref linkend="cmd-access"/>
<src:fragref linkend="cmd-fetch"/>
<src:fragref linkend="cmd-find"/>
<src:fragref linkend="cmd-forget"/>
<src:fragref linkend="cmd-help"/>
<src:fragref linkend="cmd-list"/>
<src:fragref linkend="cmd-quit"/>
<src:fragref linkend="cmd-quote"/>
<src:fragref linkend="cmd-rename"/>
<src:fragref linkend="cmd-set"/>
<src:fragref linkend="cmd-stats"/>
<src:fragref linkend="cmd-tell"/>
<src:fragref linkend="cmd-unrecognized"/>

<src:fragref linkend="proc-process-cmd"/>

<src:fragref linkend="proc-parser-init"/>

<src:fragref linkend="proc-do-crash"/>

</src:fragment>

</para>
</section>


<!-- Task body -->
<section>
<title>Command Task Body</title>
<para>
The task's body contains only the processing loop, and its required
declarations:

<src:fragment id="command-task-body">

   task body Command_Task is
<src:fragref linkend="command-decls"/>

   begin  -- Command_Task
      Parser_Init;
<src:fragref linkend="command-loop"/>

   exception
      when E: others =>
         Err (Command_Name, "Exception:  " &amp; Ada.Exceptions.Exception_Information (E));
         Do_Crash;
   end Command_Task;

</src:fragment>
</para>
</section>


<!-- Packaging -->
<section>
<title>Command Task Package</title>

<section>
<title>Command Package Body</title>
<para>
For compilation purposes, the task is contained in a package.  The package
body contains only the (anonymous) task object.  The external dependencies
are:

<itemizedlist>
<listitem>
<para><classname>Ada.Strings.Unbounded</classname> - Provides several
functions, and one constant, used by the command processor during recognition
and execution of the commands.</para>
</listitem>

<listitem>
<para><classname>Database</classname>, <classname>File</classname>, and
<classname>&outname;</classname> - Lets the command task see the request queues
of these other tasks, and place requests on them.</para>
</listitem>

<listitem>
<para><classname>Input</classname> and <classname>Ping</classname> - Lets
the command task see these task objects so they can be aborted when the
program terminates.</para>
</listitem>
</itemizedlist>

Visibility is provided to the standard library package via a
<command>use</command> clause; references to items declared in the local
packages must be fully qualified.

<src:fragment id="command-pkg-body">
with
   Ada.Characters.Handling,
   Ada.Exceptions,
   Ada.Strings.Fixed,
   Ada.Strings.Maps,
   Ada.Strings.Unbounded,
   GNAT.Regpat,
   &authname;,
   &cfgname;,
   &dataname;,
   &filename;,
   &inname;,
   &logname;,
   &outname;,
   &pingname;;

use
   Ada.Characters.Handling,
   Ada.Strings.Fixed,
   Ada.Strings.Maps,
   Ada.Strings.Unbounded,
   GNAT.Regpat,
   &logname;;

package body Command is
<src:fragref linkend="command-task-body"/>
end Command;
</src:fragment>
</para>
</section>

<section>
<title>Command Package Spec</title>

<para>The command request queue and its supporting types are declared in the
package spec so they can be used by other packages.</para>

<section>
<title>Command Package Spec Basic Type Declarations</title>
<para>
The spec declares the command-queue request record type and its supporting
operation type.  The command request record contains only a data string (the
<literal>Data</literal> field).  The data is the command as issued by the
user.  The <literal>Unbounded_String</literal>type of the
<literal>Data</literal> field is defined via <link
linkend="command-pkg-spec-context-section">the context clause</link>.  The
spec also declares the task which comprises the body of the package.

<src:fragment id="command-basic-types">
   type Operation_Type is ( Login_Operation, Finish_Login_Operation, Reply_Operation, Message_Operation,
                            Ping_Operation, Pong_Operation, Crash_Operation );

   subtype Reply_Type is string ( 1 .. 3 );

   type Request_Rec is record
      Operation:  Operation_Type;
      Origin:     Unbounded_String;
      Target:     Unbounded_String;
      Data:       Unbounded_String;
      Reply:      Reply_Type;
   end record;

   task Command_Task;
</src:fragment>
</para>
</section>

<section>
<title>Command Queue Declaration</title>
<para>
The spec instatiates the generic library package <literal>PQueue</literal>
using <literal>Request_Rec</literal> as its data-item type, and then declares
the actual command queue itself, as an item of that new queue type.

<src:fragment id="command-queue-decl">
   package Command_Queue_Pkg is new PQueue (Request_Rec);

   Requests:  Command_Queue_Pkg.Protected_Queue_Type;
</src:fragment></para>
</section>

<section id="command-pkg-spec-context-section">
<title>Command Package Spec Context Clause</title>
<para>
The command task's package spec depends on these two packages:

<itemizedlist>
<listitem>
<para><classname>Ada.Strings.Unbounded</classname>, which provides the
<literal>Unbounded_String</literal> type used for the request record's data.
</para>
</listitem>

<listitem>
<para><classname>PQueue</classname>, a local library package, which is not
defined in this document.  It is a generic package which implements a simple
protected queue type.  The code was adapted from Cohen's book <citetitle
pubwork="book">Ada as a Second Language</citetitle>.</para>
</listitem>
</itemizedlist>

Visibility is provided to the standard library package via a
<command>use</command> clause; references to items declared in the
<classname>PQueue</classname> package (whose instantiation is called
<literal>Command_Queue_Pkg</literal>) must be fully qualified.

<src:fragment id="command-pkg-spec-context">
with
   Ada.Strings.Unbounded,
   PQueue,
   &ircname;;

use
   Ada.Strings.Unbounded;
</src:fragment>
</para>
</section>

<section>
<title>Package Spec Proper</title>
<para>

The package spec puts together the context clause and the declarations to make
a compilation unit.

<src:fragment id="command-pkg-spec">
<src:fragref linkend="command-pkg-spec-context"/>

package Command is

   &pkg;_Name:  constant string := "&pkg;";

<src:fragref linkend="command-basic-types"/>

<src:fragref linkend="command-queue-decl"/>
end Command;
</src:fragment>
</para>
</section>

</section>
</section>
</section>

</article>
