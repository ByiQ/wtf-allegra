<?xml version="1.0" standalone="no"?>
<!DOCTYPE xweb PUBLIC "-//NDW-WMR//DTD DocBook XML V4.1.2-based Extension XWeb V1.0//EN"
                      "file:///opt/litprog/dtd/xweb.dtd" [
<!ENTITY % entities SYSTEM "entities.inc.dtd">
%entities;
<!ENTITY pkg      "&cmdname;">
]>

<article xmlns:src="http://nwalsh.com/xmlns/litprog/fragment"
         xmlns:xsl="http://www.w3.org/1999/XSL/Transform">



<!-- Article meta-data -->
<articleinfo>
<title>&prog; Command Processor</title>

<author>
<firstname>Chip</firstname>
<surname>Richards</surname>
</author>

<address><email>chipr@niestu.com</email></address>
<publisher>
<publishername>NiEstu</publishername>
<address><otheraddr><ulink url="&site;/allegra/"></ulink></otheraddr></address>
</publisher>

<releaseinfo>Version 1.0</releaseinfo>
<date>30 December 2003</date>

<legalnotice>
<para>This code is released under the terms of the <ulink
url="http://www.gnu.org/licenses/gpl.html">GNU General Public License</ulink>,
version 2.</para>
</legalnotice>
</articleinfo>


<!-- The Command task -->
<section id="command-task">
<title>The Command Task</title>

<para>The command task is the brains of the program.  It interprets input
commands and dispatches requests for information to the database and file
access tasks, as well as handling some commands itself.  In &prog;, commands
come from users on the IRC server.</para>

<section>
<title>Command Loop</title>
<para>
The heart of the command task is an endless loop.  It removes a request from
the command queue, parses its content as a command, then executes the command.
<link linkend="cmd-set">The command set</link> for &prog; is fairly simple,
and owes much of its design to David Sobon's blootbot, which in turn was based
on infobot by Kevin Lenzo and Patrick Cole.

<src:fragment id="command-loop">
   loop
      Requests.Dequeue (Request);
      <src:fragref linkend="process-request"/>
   end loop;
</src:fragment>

The task spends most of its time sitting on the
<methodname>Dequeue</methodname> statement, waiting for a command request to
be placed in its queue by one of the other tasks.  (In &prog;, only <link
linkend="&inpkg;">the input task</link> puts command requests on the
command queue, though any task can send a <quote>crash</quote> request.)
</para>


<!-- Command Recognition -->
<section>
<title>Recognizing Command Messages</title>
<para>The &pkg; task receives requests for several types of operations.  Most
of these operations have fixed actions.  Only messages require additional
action, which is to inspect them to determine if they contain user
commands.</para>

<para>&prog;'s user commands come in IRC messages, either sent in the channel,
or as direct private messages.  Channel messages are only passed to the &pkg;
task by the &inname; task if they contain the program's nick, or if they begin
with the shorthand string (if it is configured).  Private messages are always
passed.  So we begin with the assumption that all message requests we receive
are worthy of the command processor's attention.</para>

<section>
<title>Prefix Scanning</title>
<para>Both channel messages and private messages may begin with either the
shorthand string, or the program's nick followed by one of several separator
characters.  This prefix is required for a channel message to be recognized as
a command, but for consistency is allowed on private messages too.  If it's
present, its presence is noted, and it is stripped; if not, we use the entire
message as the actual command string.  If shorthand recognition is enabled, we
look for that first.  Note that with the leading-nick form, the actual command
begins one position past the separator character (My_Nick'Length + 2).

<src:fragment id="prefix-scan">
   Has_Prefix := false;
   Command := To_Unbounded_String (Message);
   if Shorthand'Length &gt; 0 and then Index (Message, Shorthand) = 1 then
      Has_Prefix := true;
      Command := To_Unbounded_String (Message (Shorthand'Length + 1 .. Message'Length));
   elsif Leading_Nick (Message, My_Nick) then
      Has_Prefix := true;
      Command := To_Unbounded_String (Message (My_Nick'Length + 2 .. Message'Length));
   end if;
   Command := Trim (Command, Side => Ada.Strings.Both);
</src:fragment>
</para>
</section>

<section>
<title>Command Recognition</title>
<para>Recognition continues by assuming that the message is
<emphasis>not</emphasis> a command, until it is proven to be one.  It then
determines whether we have a private message or a channel message by checking
the message's target.  Private messages are always assumed to be commands.
Channel messages are commands only if they have a recognized prefix.  In
both cases, we set the message type and destination, which determine how the
response is constructed.

<src:fragment id="recognize">
   Is_Command := false;
   if To_Lower (To_String (Request.Target)) = My_Nick then
      Is_Command := true;
      Msg_Type := PrivMsg;
      Destination := Sender.Nick;
   else
      Is_Command := Has_Prefix;
      Msg_Type := ChanMsg;
      Destination := Request.Target;
   end if;
</src:fragment>
</para>
</section>

<section>
<title>Check For Leading-Nick Prefix</title>

<para>This function checks for the leading-nick message prefix, and returns
true if the input message has one, false if not.  We ensure that the message
contains at least one character after the separator, by checking for
<literal>Nick'Length + 2</literal>.</para>

<src:fragment id="func-leadnick">
   function Leading_Nick (Msg : in string;   Nick:  in string) return boolean is
   begin  -- Leading_Nick
      if Msg'Length &gt; Nick'Length + 2 then
         if Index (To_Lower (Msg), Nick) = 1 and Is_In (Msg (Nick'Length + 1), Separators) then
            return true;
         end if;
      end if;
      return false;
   end Leading_Nick;
</src:fragment>
</section>

</section>


<!-- Request processing -->
<section>
<title>Request Processing</title>
<para>The task handles incoming requests by selecting the processing they
require, based on the request's operation type.  The operations are:

<itemizedlist>
<listitem>
<para><literal>Crash_Operation</literal> - Received when another task has
suffered an unhandled exception.  The request's <varname>Data</varname> field
contains the text of the exception information, to be logged if
desired.</para>
</listitem>

<listitem>
<para><literal>Login_Operation</literal> - Received at program startup, and
after a reconnect, to ask the program to log in to the IRC server and join its
configured channel.  The request contains no additional data.</para>
</listitem>

<listitem>
<para><literal>Message_Operation</literal> - Received when the &inname; task
sees something that might be a user command.  That is, a private message
addressed to &prog;, or a channel message containing the program's nick.  The
request's <varname>Origin</varname> field contains the sender's user ID, in
IRC <quote>msgto</quote> format; the <varname>Target</varname> field contains
the message's target (either a nick or a channel name), and the
<varname>Data</varname> field contains the text of the message.</para>
</listitem>

<listitem>
<para><literal>Ping_Operation</literal> - Received when a ping message comes
from the server, or when the &pingname; task gets lonely.  The request's
<varname>Data</varname> field contains the ping message's parameter.</para>
</listitem>

<listitem>
<para><literal>Reply_Operation</literal> - Received when a numeric IRC reply
comes in from the server.  These can be error messages, status messages, or
several other sorts.  Currently, the command task ignores them, but in the
future, they will be used for several purposes, including better handling of
nick collisions, login failures, user tracking perhaps, etc.  The request's
<varname>Reply</varname> field contains the three-digit numeric reply code,
and the <varname>Data</varname> field contains the reply's parameter(s).</para>
</listitem>
</itemizedlist>

<src:fragment id="process-request">
   case Request.Operation is

      when Login_Operation =&gt;
         Info (Command_Name, "Login as " &amp; &cfgname;.Get_Value (&cfgname;.Item_Nick) &amp; " to " &amp;
                             "#" &amp; &cfgname;.Get_Value (&cfgname;.Item_Channel));
         Output_Request.Operation := &outname;.Nick_Operation;
         Output_Request.Data      := To_Unbounded_String (&cfgname;.Get_Value (&cfgname;.Item_Nick));
         &outname;.Requests.Enqueue (Output_Request);
         Output_Request.Operation := &outname;.User_Operation;
         Output_Request.Data      := To_Unbounded_String (&cfgname;.Get_Value (&cfgname;.Item_UserName) &amp;
                                                          " 0 * :" &amp; &cfgname;.Get_Value (&cfgname;.Item_RealName));
         &outname;.Requests.Enqueue (Output_Request);
         delay 2.0;  -- doesn't delay the write, but ...
         Output_Request.Operation := &outname;.Join_Operation;
         Output_Request.Data      := To_Unbounded_String ("#" &amp; &cfgname;.Get_Value (&cfgname;.Item_Channel));
         &outname;.Requests.Enqueue (Output_Request);

      when Ping_Operation =&gt;
         Dbg (Command_Name, "Ping to " &amp; To_String (Destination));
         Output_Request.Operation := &outname;.Ping_Operation;
         Output_Request.Data      := Request.Data;
         &outname;.Requests.Enqueue (Output_Request);

      when Message_Operation =&gt;
         declare
            Command    : Unbounded_String;
            Has_Prefix : boolean;
            Is_Command : boolean;
            Message    : string := To_String (Request.Data);
            My_Nick    : string := To_Lower (Config.Get_Value (Config.Item_Nick));
            Shorthand  : string := &cfgname;.Get_Value (&cfgname;.Item_Shorthand);
         begin
            &ircname;.Parse_MsgTo (Request.Origin, Sender);
            <src:fragref linkend="prefix-scan"/>
            <src:fragref linkend="recognize"/>
            if Is_Command then
               Do_Exit := false;
               Process_Command (Command, Sender);
               exit when Do_Exit;
            else
            -- Quips go here
            end if;
         end;

      when Crash_Operation =&gt;
         Err (Command_Name, "Crash:  " &amp; To_String (Request.Data));
         Shutdown;
         exit;

      when Reply_Operation =&gt;
         null;  -- for now
   end case;
</src:fragment>
</para>

<para>It may be argued that it would be <quote>cleaner</quote> in some ways
for the input and ping tasks to have their own <quote>back-channel</quote>
queues, to accept the shutdown command at the very least, if not other as yet
unforeseen command operations, instead of having the command task forcibly
<quote>shoot them in the head</quote> as it does now.  However, monitoring
both that queue and their primary input source (the IRC socket, in the case of
the input task, and the clock in the ping task) would complicate the logic,
and seems a high price to pay for something that can be solved in this fairly
straightforward manner using standard Ada facilities.  Suggestions are
welcome, however.</para>

<section>
<title>Program Shutdown</title>

<para>This procedure causes the program to close up shop.  It sends shutdown
requests to the tasks which accept them, and aborts the tasks which don't,
waits a bit for the whole thing to settle down (which should eventually be
replaced by a wait for the appropriate server reply code in response to the
logout request), then closes the log.  It is called when it accepts a
<quote>quit</quote> command, or when this or another task crashes.

<src:fragment id="proc-shutdown">
   procedure Shutdown is
   begin  -- Shutdown
      Database_Request.Operation := &dataname;.Shutdown_Operation;
      File_Request.Operation     := &filename;.Shutdown_Operation;
      Output_Request.Operation   := &outname;.Shutdown_Operation;
      &dataname;.Requests.Enqueue (Database_Request);
      &filename;.Requests.Enqueue (File_Request);
      &outname;.Requests.Enqueue  (Output_Request);
      abort &inname;.Input_Task;
      abort &pingname;.Ping_Task;
      delay 3.0;
      &logname;.WrapUp;
   end Shutdown;
</src:fragment>
</para>
</section>

</section>

</section>


<!-- Task body declarations -->
<section>
<title>Command Parsing</title>

<para></para>

<src:fragment id="proc-process-cmd">
   procedure Process_Command (Cmd:  in Unbounded_String;   Sender:  in &ircname;.MsgTo_Rec) is

   procedure Unrecognized is

      Msg : string := "I don't recognize that command.";

   begin  -- Unrecognized
      Output_Request.Operation := Output.Message_Operation;
      Output_Request.Destination := Destination;
      if Msg_Type = PrivMsg then
         Output_Request.Data := To_Unbounded_String (Msg);
      else
         Output_Request.Data := "Sorry " &amp; Sender.Nick &amp; ", " &amp; Msg;
      end if;
      &outname;.Requests.Enqueue (Output_Request);
   end Unrecognized;

   procedure Quit is
   begin  -- Quit
      if Auth.Permitted (Request.Origin, &cfgname;.Cmd_Quit) then
         Info (Command_Name, "Executing shutdown request from " &amp; To_String (Request.Origin));
         Shutdown;
         Do_Exit := true;
      else
         Info (Command_Name, "Rejecting shutdown request from " &amp; To_String (Request.Origin));
         Output_Request.Operation := Output.Message_Operation;
         Output_Request.Destination := Destination;
         Output_Request.Data := To_Unbounded_String ("I'm sorry, I don't know you well enough to take orders from you.");
         &outname;.Requests.Enqueue (Output_Request);
      end if;
   end Quit;

   begin  -- Process_Command
      Dbg (Command_Name, "Processing command """ &amp; To_String (Cmd) &amp; """ from " &amp; To_String (Sender.Nick));
      if Cmd = "quit" then
         Quit;
      else
         Unrecognized;
      end if;
   end Process_Command;
</src:fragment>
</section>

<!-- Task body declarations -->
<section>
<title>Command Task Declarations</title>

<para>
The command loop uses these variables:

<itemizedlist>
<listitem>
<para><literal>Request</literal> - A local item of the type of the
command-queue entries, used to receive the next item taken from the request
queue.</para>
</listitem>

<listitem>
<para><literal>Database_Request</literal>, <literal>File_Request</literal>,
and <literal>Output_Request</literal> - Request-queue variables for each of
the three subordinate tasks that the command task talks to.  Used by the
command execution code to build requests to send to other tasks.</para>
</listitem>
</itemizedlist>

<src:fragment id="command-decls">
      Separators : Character_Set := To_Set (",:~");

      type Message_Type_Enm is ( PrivMsg, ChanMsg );

      Database_Request : &dataname;.Request_Rec;
      Destination      : Unbounded_String;
      Do_Exit          : boolean;
      File_Request     : &filename;.Request_Rec;
      Msg_Type         : Message_Type_Enm;
      Output_Request   : &outname;.Request_Rec;
      Request          : Request_Rec;
      Sender           : &ircname;.MsgTo_Rec;

<src:fragref linkend="func-leadnick"/>

<src:fragref linkend="proc-shutdown"/>

<src:fragref linkend="proc-process-cmd"/>
</src:fragment>

</para>
</section>


<!-- Task body -->
<section>
<title>Command Task Body</title>
<para>
The task's body contains only the processing loop, and its required
declarations:

<src:fragment id="command-task-body">

   task body Command_Task is
<src:fragref linkend="command-decls"/>

   begin  -- Command_Task
<src:fragref linkend="command-loop"/>

   exception
      when E: others =>
         Err (Command_Name, "Exception:  " &amp; Ada.Exceptions.Exception_Information (E));
         Shutdown;
   end Command_Task;

</src:fragment>
</para>
</section>


<!-- Packaging -->
<section>
<title>Command Task Package</title>

<section>
<title>Command Package Body</title>
<para>
For compilation purposes, the task is contained in a package.  The package
body contains only the (anonymous) task object.  The external dependencies
are:

<itemizedlist>
<listitem>
<para><classname>Ada.Strings.Unbounded</classname> - Provides several
functions, and one constant, used by the command processor during recognition
and execution of the commands.</para>
</listitem>

<listitem>
<para><classname>Database</classname>, <classname>File</classname>, and
<classname>&outname;</classname> - Lets the command task see the request queues
of these other tasks, and place requests on them.</para>
</listitem>

<listitem>
<para><classname>Input</classname> and <classname>Ping</classname> - Lets
the command task see these task objects so they can be aborted when the
program terminates.</para>
</listitem>
</itemizedlist>

Visibility is provided to the standard library package via a
<command>use</command> clause; references to items declared in the local
packages must be fully qualified.

<src:fragment id="command-pkg-body">
with
   Ada.Characters.Handling,
   Ada.Exceptions,
   Ada.Strings.Fixed,
   Ada.Strings.Maps,
   Ada.Strings.Unbounded,
   &authname;,
   &cfgname;,
   &dataname;,
   &filename;,
   &inname;,
   &logname;,
   &outname;,
   &pingname;;

use
   Ada.Characters.Handling,
   Ada.Strings.Fixed,
   Ada.Strings.Maps,
   Ada.Strings.Unbounded,
   &logname;;

package body Command is
<src:fragref linkend="command-task-body"/>
end Command;
</src:fragment>
</para>
</section>

<section>
<title>Command Package Spec</title>

<para>The command request queue and its supporting types are declared in the
package spec so they can be used by other packages.</para>

<section>
<title>Command Package Spec Basic Type Declarations</title>
<para>
The spec declares the command-queue request record type and its supporting
operation type.  The command request record contains only a data string (the
<literal>Data</literal> field).  The data is the command as issued by the
user.  The <literal>Unbounded_String</literal>type of the
<literal>Data</literal> field is defined via <link
linkend="command-pkg-spec-context-section">the context clause</link>.  The
spec also declares the task which comprises the body of the package.

<src:fragment id="command-basic-types">
   type Operation_Type is ( Login_Operation, Reply_Operation, Message_Operation, Ping_Operation, Crash_Operation );

   subtype Reply_Type is string ( 1 .. 3 );

   type Request_Rec is record
      Operation:  Operation_Type;
      Origin:     Unbounded_String;
      Target:     Unbounded_String;
      Data:       Unbounded_String;
      Reply:      Reply_Type;
   end record;

   task Command_Task;
</src:fragment>
</para>
</section>

<section>
<title>Command Queue Declaration</title>
<para>
The spec instatiates the generic library package <literal>PQueue</literal>
using <literal>Request_Rec</literal> as its data-item type, and then declares
the actual command queue itself, as an item of that new queue type.

<src:fragment id="command-queue-decl">
   package Command_Queue_Pkg is new PQueue (Request_Rec);

   Requests:  Command_Queue_Pkg.Protected_Queue_Type;
</src:fragment></para>
</section>

<section id="command-pkg-spec-context-section">
<title>Command Package Spec Context Clause</title>
<para>
The command task's package spec depends on these two packages:

<itemizedlist>
<listitem>
<para><classname>Ada.Strings.Unbounded</classname>, which provides the
<literal>Unbounded_String</literal> type used for the request record's data.
</para>
</listitem>

<listitem>
<para><classname>PQueue</classname>, a local library package, which is not
defined in this document.  It is a generic package which implements a simple
protected queue type.  The code was adapted from Cohen's book <citetitle
pubwork="book">Ada as a Second Language</citetitle>.</para>
</listitem>
</itemizedlist>

Visibility is provided to the standard library package via a
<command>use</command> clause; references to items declared in the
<classname>PQueue</classname> package (whose instantiation is called
<literal>Command_Queue_Pkg</literal>) must be fully qualified.

<src:fragment id="command-pkg-spec-context">
with
   Ada.Strings.Unbounded,
   PQueue,
   &ircname;;

use
   Ada.Strings.Unbounded;
</src:fragment>
</para>
</section>

<section>
<title>Package Spec Proper</title>
<para>

The package spec puts together the context clause and the declarations to make
a compilation unit.

<src:fragment id="command-pkg-spec">
<src:fragref linkend="command-pkg-spec-context"/>

package Command is

   &pkg;_Name:  constant string := "&pkg;";

<src:fragref linkend="command-basic-types"/>

<src:fragref linkend="command-queue-decl"/>
end Command;
</src:fragment>
</para>
</section>

</section>
</section>
</section>


</article>
