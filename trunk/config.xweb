<?xml version="1.0" standalone="no"?>
<!DOCTYPE xweb PUBLIC "-//NDW-WMR//DTD DocBook XML V4.1.2-based Extension XWeb V1.0//EN"
                      "file:///opt/litprog/dtd/xweb.dtd" [
<!ENTITY svc      "configuration">
<!ENTITY atbl     "cmdlevels">
<!ENTITY ctbl     "config">
<!ENTITY utbl     "usrlevels">
<!ENTITY namelen  "16">
<!ENTITY nick     "&prog;">
<!ENTITY % entities SYSTEM "entities.inc.dtd">
%entities;
<!ENTITY pkg      "&cfgname;">
]>

<article xmlns:src="http://nwalsh.com/xmlns/litprog/fragment"
         xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

<!-- Article meta-data -->
<articleinfo>
<title>&prog; Configuration Package</title>

<author>
<firstname>Chip</firstname>
<surname>Richards</surname>
</author>

<address><email>chipr@niestu.com</email></address>
<publisher>
<publishername>NiEstu</publishername>
<address><otheraddr><ulink url="&site;/allegra/"></ulink></otheraddr></address>
</publisher>

<releaseinfo>Version 1.0</releaseinfo>
<date>29 December 2003</date>

<legalnotice>
<para>This code is released under the terms of the <ulink
url="http://www.gnu.org/licenses/gpl.html">GNU General Public License</ulink>,
version 2.</para>
</legalnotice>
</articleinfo>


<!--++++++++++++++++++++++++++++++++-->
<!--            API  section        -->
<!--++++++++++++++++++++++++++++++++-->
<section>
<title>API</title>

<section>
<title>Overview</title>

<para>This package provides &prog; with program configuration information.
Most of the information is kept in tables in the program's database, though
some few <quote>bootstrap</quote> values are expressed as constants.</para>

<para>As configuration information is pretty simple, so is this package's API.
The only complicating factor is that we must ensure in &prog;'s multi-tasking
environment that the configuration information has been read before any task
tries to access it.  The interface provides two services, a function which
returns a given named configuration value, and a function which returns a
command's authorization level.</para>

</section>

<section>
<title>Service Details</title>

<section>
<title>The <function>Get_Value</function> Function</title>

<src:fragment id="func-getv">
   function Get_Value (Item:  Config_Item)
   return string
</src:fragment>

<para>The <function>Get_Value</function> function returns the requested named
configuration value.  This is for accessing all configuration values except
command authorization levels.</para>

</section>

<section>
<title>The <function>Get_Auth_Level</function> Function</title>

<src:fragment id="func-geta">
   function Get_Auth_Level (Command:  Command_Type)
   return Auth_Level
</src:fragment>

<para>The <function>Get_Auth_Level</function> fuction returns the numeric
authorization level that has been configured for the given command
type.</para>

</section>

<section>
<title>The <function>Init</function> Procedure</title>

<src:fragment id="proc-init">
   procedure Init
</src:fragment>

<para>The <function>Init</function> procedure (re-)initializes the (cached)
configuration data held in memory.  It is called at package initialization
time, and may be called at any time during execution, to re-read new
configuration settings from the database server.</para>

</section>

</section>

</section>


<!--++++++++++++++++++++++++++++++++-->
<!--    Implementation section      -->
<!--++++++++++++++++++++++++++++++++-->
<section>
<title>Implementation</title>

<para>Given the simple requirements of &prog;, the configuration module is
correspondingly simple.  It uses the <classname>DB</classname> package
services to read the configuration data from the program's database.  To
synchronize access to the values, specifically to ensure that the values have
been read from the database before allowing any application calls to fetch
them, the package uses a protected object.</para>


<section>
<title>Access Control</title>

<para>A simple protected object, essentially a semaphore, controls access to
the configuration values in memory.  The package init code calls the
<function>Data_Available</function> procedure to indicate that the data is now
in memory and is available to be accessed.  The <function>Get_Value</function>
function calls the <function>Wait_For_Data</function> entry before accessing
any values.  This ensures that the read operation is complete and the data is
actually in memory before attempting to use any of the values.</para>

<src:fragment id="access-control">
   protected Access_Control is
      procedure Data_Available;
      entry Wait_For_Data;
   private
      Is_Available:  boolean := false;
   end Access_Control;

   protected body Access_Control is
      procedure Data_Available is
      begin
         Is_Available := true;
      end Data_Available;

      entry Wait_For_Data when Is_Available is
      begin
         null;
      end Wait_For_Data;
   end Access_Control;
</src:fragment>

</section>


<section>
<title>Accessing the Configuration Values</title>

<para>Given the preparation done by the package init code, accessing the
values is a very simple job.  We simply ensure that the values are present by
calling the protected entry <function>Wait_For_Data</function>, then use the
given enumeration value to index into the configuration table for the value.
It is converted from the storage format, which is
<literal>Unbounded_String</literal>, into a standard <literal>string</literal>
value, before returning it.</para>

<src:fragment id="getv-body">
   Access_Control.Wait_For_Data;
   return To_String (Config_Values (Item));
</src:fragment>

</section>


<section>
<title>Accessing the Authorization Levels</title>

<para>Accessing the auth levels is also quite simple, since most of the work
has been done by the init code.  We ensure that the values are present by
calling the protected entry <function>Wait_For_Data</function>, then using the
given command-type enumeration value to index into the authorization level
table for the value.
</para>

<src:fragment id="geta-body">
   Access_Control.Wait_For_Data;
   return Cmd_Auth_Levels (Command);
</src:fragment>

</section>

</section>


<!--++++++++++++++++++++++++++++++++-->
<!--        Packaging section       -->
<!--++++++++++++++++++++++++++++++++-->
<section>
<title>Packaging</title>

<para>Packaging the code for compilation is straightforward.  The package spec
is quite small, given the few services it offers.</para>


<section>
<title>The Package Spec</title>

<para>The package spec defines the <function>Get_Value</function> and
<function>Get_Auth_Level</function> functions, the <function>Init</function>
procedure, and the enumeration types used by the package and its users to
identify individual configuration values and auth level.  It also defines the
program's database name and the relevant table names.  Only predefined data
types are used, so the spec requires no context clause.</para>

<para>The presence of the command-type enumeration here makes a rather tight
binding between this package and <ulink url="&cmdpkg;">the &cmdname;
package</ulink>, which isn't particularly desirable.  Whenever a new command
type is added, both packages must be updated.  We're working on an alternative
to this design, but this will do for now.</para>

<src:fragment id="config-pkg-spec">
package &pkg; is

   Allegra_DB:     string := "&progdb;";
   Config_Tbl:     string := "&ctbl;";
   Cmd_Auth_Tbl:   string := "&atbl;";
   UserLvl_Tbl:    string := "&utbl;";

   type Config_Item is
   (
      Item_None,
      Item_ARMPath,
      Item_Channel,
      Item_Host,
      Item_LogLevel,
      Item_LogPath,
      Item_Nick,
      Item_Port,
      Item_Quips,
      Item_RealName,
      Item_Shorthand,
      Item_UserName
   );

   type Command_Type is
   (
      Cmd_None,
      Cmd_Access,
      Cmd_Fetch,
      Cmd_Find,
      Cmd_Forget,
      Cmd_Help,
      Cmd_List,
      Cmd_Quit,
      Cmd_Quote,
      Cmd_Rename,
      Cmd_Set,
      Cmd_Stats,
      Cmd_Tell
   );

   Min_Auth_Level : constant :=  0;
   Max_Auth_Level : constant := 10;
   subtype Auth_Level is integer range Min_Auth_Level .. Max_Auth_Level;

<src:fragref linkend="func-getv"/>;

<src:fragref linkend="func-geta"/>;

<src:fragref linkend="proc-init"/>;

end &pkg;;
</src:fragment>

</section>

<section>
<title>The Package Body</title>

<para>The package body is a bit longer, as it makes some local declarations
used to manage the configuration data, and it contains the initialization code
which actually reads the configuration values.</para>

<section>
<title>The Context Clause</title>

<para>The package uses two external packages for their types and
subroutines.</para>

<itemizedlist>
<listitem>
<para><classname>Ada.Strings.Unbounded</classname> - The configuration values
are stored as unbounded strings, so the type and conversion routines are used
to convert them to and from standard strings.  Visibility is provided via a
<command>use</command> clause.</para>
</listitem>

<listitem>
<para><classname>DB</classname> - Provides access to the external database
where the configuration values are stored.  Only read access is performed;
write access is provided by a separate application.</para>
</listitem>
</itemizedlist>

<src:fragment id="context">
with
   Ada.Command_Line,
   Ada.Strings.Unbounded,
   DB;

use
   Ada.Command_Line,
   Ada.Strings.Unbounded;
</src:fragment>

</section>

<section>
<title>The Mapping Tables</title>

<para>Statically-initialized tables are used to map between a configuration
value's symbolic name as stored in the database, and the enumeration value
used to identify it in the application, and similarly to map between a
command-type's symbolic name and its enumeration type.  One constant and three
types are used to support these tables.</para>

<itemizedlist>
<listitem>
<para><literal>Name_Len_Max</literal> - an integer constant, which must be as
large as or larger than the maximum size of the <literal>name</literal> field
in the database.</para>
</listitem>

<listitem>
<para><literal>Item_Name</literal> - a fixed-length string type, whose upper
bound is set by <literal>Name_Len_Max</literal>.</para>
</listitem>

<listitem>
<para><literal>Config_Mapping_Rec</literal> - a record that pairs the item name
strings with their enumeration values.</para>
</listitem>

<listitem>
<para><literal>Cfg_Map_Array</literal> - an unconstrained array type of
configuration mapping records.</para>
</listitem>

<listitem>
<para><literal>Cmd_Auth_Mapping_Rec</literal> - a record that pairs the
command-type name strings with their enumeration values.</para>
</listitem>

<listitem>
<para><literal>Cmd_Map_Array</literal> - an unconstrained array type of
command auth level mapping records.</para>
</listitem>

<listitem>
<para><literal>Cfg_Map</literal> - the configuration mapping table, an array
of mapping records whose size is set by its initialization clause.</para>
</listitem>

<listitem>
<para><literal>Cmd_Map</literal> - the command-type mapping table, an array of
mapping records whose size is set by its initialization clause.</para>
</listitem>
</itemizedlist>

<src:fragment id="mapping">
   Name_Len_Max:  constant := &namelen;;

   subtype Item_Name is string (1 .. Name_Len_Max);

   type Config_Mapping_Rec is record
      Name:  Item_Name;
      Item:  Config_Item;
   end record;

   type Cfg_Map_Array is array ( positive range &lt;&gt; ) of Config_Mapping_Rec;

   type Cmd_Auth_Mapping_Rec is record
      Name:  Item_Name;
      Item:  Command_Type;
   end record;

   type Cmd_Map_Array is array ( positive range &lt;&gt; ) of Cmd_Auth_Mapping_Rec;

   Cfg_Map:  Cfg_Map_Array :=
   (
      ("                ", Item_None),
      ("armpath         ", Item_ARMPath),
      ("channel         ", Item_Channel),
      ("host            ", Item_Host),
      ("loglevel        ", Item_LogLevel),
      ("logpath         ", Item_LogPath),
      ("nick            ", Item_Nick),
      ("port            ", Item_Port),
      ("quips           ", Item_Quips),
      ("realname        ", Item_RealName),
      ("shorthand       ", Item_Shorthand),
      ("username        ", Item_UserName)
   );

   Cmd_Map:  Cmd_Map_Array :=
   (
      ("                ", Cmd_None),
      ("access          ", Cmd_Access),
      ("fetch           ", Cmd_Fetch),
      ("find            ", Cmd_Find),
      ("forget          ", Cmd_Forget),
      ("help            ", Cmd_Help),
      ("list            ", Cmd_List),
      ("quit            ", Cmd_Quit),
      ("quote           ", Cmd_Quote),
      ("rename          ", Cmd_Rename),
      ("set             ", Cmd_Set),
      ("stats           ", Cmd_Stats),
      ("tell            ", Cmd_Tell)
   );
</src:fragment>

</section>

<section>
<title>The Configuration Values</title>

<para>The actual configuration values are read into an array, indexed by the
configuration item enumeration type.  The array elements are unbounded
strings, which are converted from standard strings on the way in, and back to
them on the way back out.</para>

<src:fragment id="cfg-values">
   Config_Values:  array ( Config_Item ) of Unbounded_String;
</src:fragment>

</section>

<section>
<title>The Authorization Levels</title>

<para>As with the configuration values, the auth levels are read into an
array, indexed by the command type enumeration.  The array elements are of
type <literal>Auth_Level</literal>, which is an integer subrange.</para>

<src:fragment id="auth-levels">
   Cmd_Auth_Levels:  array ( Command_Type ) of Auth_Level;
</src:fragment>

</section>

<section>
<title>Reading the Configuration Data</title>

<para>The package initialization code is the most complicated part of the
whole package.  It is responsible for reading the configuration data from the
program's database, and mapping it into an in-memory form easily accessible by
the rest of &prog;.  Once that is done, it disconnects the database connection
and sets the semaphore to indicate that the data is now available.</para>

<src:fragment id="init-body">
<src:fragref linkend="fetch-data"/>
<src:fragref linkend="map-cfg"/>
<src:fragref linkend="map-auth"/>
<src:fragref linkend="override"/>
   DB.Disconnect (Handle);
   Access_Control.Data_Available;
</src:fragment>

<section>
<title>Fetch the Data</title>

<para>The first step in this process is to connect to the external database,
and then fetch the data from it.  It identifies the database and the tables
containing the configuration data by means of constants.</para>

<src:fragment id="fetch-data">
   DB.Connect (Handle, Host => "", DB => Allegra_DB);
   DB.Fetch (Handle, "*", Config_Tbl,   "", Cfg_Data);
   DB.Fetch (Handle, "*", Cmd_Auth_Tbl, "", Auth_Data);
</src:fragment>

</section>

<section>
<title>Mapping the Data</title>

<para>Once the data has been fetched, we must convert the value names to the
enumeration constants used by the application when querying the values.  The
actual configuration value or auth level is then stored in an array indexed by
the enumeration value.  This is done by a simple linear search of a table,
which was deemed acceptable because of the small number of values, and the
fact that the mapping is done infrequently.  Any unrecognized parameter names
are simply skipped, so be sure to update the enumeration and the table when
adding new configuration parameters or command types.</para>

<para>We considered a scheme to use the actual name string for accessing the
parameters, presumable via a hash table or something similar, but that
mechanism is overkill in this situation.</para>

<src:fragment id="map-cfg">
   for Row in 1 .. DB.Rows (Cfg_Data) loop
      declare
         Name:  string := DB.Get_Value (Cfg_Data, Row, "name");
      begin
         Item := Item_None;
         for Index in Cfg_Map'Range loop
            if Cfg_Map (Index).Name (1 .. Name'Length) = Name then
               Item := Cfg_Map (Index).Item;
               exit;
            end if;
         end loop;
         if Item /= Item_None then
            declare
               Value_Str:  string := DB.Get_Value (Cfg_Data, Row, "value");
            begin
               Config_Values (Item) := To_Unbounded_String (Value_Str);
            end;
         end if;         
      end;
   end loop;
</src:fragment>

<src:fragment id="map-auth">
   for Row in 1 .. DB.Rows (Auth_Data) loop
      declare
         Name:  string := DB.Get_Value (Auth_Data, Row, "name");
      begin
         Cmd := Cmd_None;
         for Index in Cmd_Map'Range loop
            if Cmd_Map (Index).Name (1 .. Name'Length) = Name then
               Cmd := Cmd_Map (Index).Item;
               exit;
            end if;
         end loop;
         if Cmd /= Cmd_None then
            Cmd_Auth_Levels (Cmd) := DB.Get_Value (Auth_Data, Row, "level");
         end if;         
      end;
   end loop;
</src:fragment>

</section>

<section>
<title>Command-Line Overrides</title>

<para>To facilitate testing and other alternative uses, &prog; accepts some
positional configuration values on the command line.  All are optional, but
being positional, if you wish to specify a different nick, for example, you
must give the host and port arguments too, even if they are the same ones as
found in the configuration database.  If given, these values override the
values found in the configuration database.  They are, in order:

<itemizedlist>
<listitem>
<para>Remote host, given as the first command-line argument.  An Internet host
name.</para>
</listitem>

<listitem>
<para>Remote port, given as the second argument.  A decimal number.</para>
</listitem>

<listitem>
<para>Nick, given as the third argument.  Any string that is legal as an IRC
nickname.</para> nick
</listitem>

<listitem>
<para>Channel, given as the fourth argument.  Since the <quote>#</quote>
character is a meta-character for many common shells (including bash), it must
be omitted from this value.  Any string that is legal as an IRC channel name,
without the leading <quote>#</quote>.</para>
</listitem>
</itemizedlist>

<src:fragment id="override">
   if Argument_Count &gt;= 1 then
      Config_Values (Item_Host) := To_Unbounded_String (Argument (1));
   end if;
   if Argument_Count &gt;= 2 then
      Config_Values (Item_Port) := To_Unbounded_String (Argument (2));
   end if;
   if Argument_Count &gt;= 3 then
      Config_Values (Item_Nick) := To_Unbounded_String (Argument (3));
   end if;
   if Argument_Count &gt;= 4 then
      Config_Values (Item_Channel) := To_Unbounded_String (Argument (4));
   end if;
   if Argument_Count &gt;= 5 then
      Config_Values (Item_LogPath) := To_Unbounded_String (Argument (5));
   end if;
</src:fragment>

</para>
</section>

<section>
<title>Initialization Variables</title>

<para>These variables are required to support the initialization code:</para>

<src:fragment id="init-vars">
   Handle:    DB.DB_Handle;
   Auth_Data: DB.DB_Result;
   Cfg_Data:  DB.DB_Result;
   Item:      Config_Item;
   Cmd:       Command_Type;
</src:fragment>

<itemizedlist>
<listitem>
<para><varname>Auth_Data</varname> - The database result structure used to
fetch the configured command authorization levels.</para>
</listitem>

<listitem>
<para><varname>Cfg_Data</varname> - The database result structure used to
fetch the configuration item values.</para>
</listitem>

<listitem>
<para><varname>Cmd</varname> - Enum variable which holds the result of the
command type's symbolic name lookup.</para>
</listitem>

<listitem>
<para><varname>Handle</varname> - The database handle, used for all data
fetches.</para>
</listitem>

<listitem>
<para><varname>Item</varname> - Enum variable which holds the result of the
configuration item's symbolic name lookup.</para>
</listitem>
</itemizedlist>
</section>
</section>

<section>
<title>Compilation Unit</title>

<para>Putting all the code bits together gives us a compilation unit for the
package body.  The package initialization code reads the configuration from
the database, and once it has finished reading, sets the guard to allow other
users to access the configuration values.</para>

<src:fragment id="config-pkg-body">
<src:fragref linkend="context"/>

package body &pkg; is

<src:fragref linkend="access-control"/>

<src:fragref linkend="mapping"/>

<src:fragref linkend="cfg-values"/>

<src:fragref linkend="auth-levels"/>

<src:fragref linkend="func-getv"/> is
begin  -- Get_Value
<src:fragref linkend="getv-body"/>
end Get_Value;

<src:fragref linkend="func-geta"/> is
begin  -- Get_Auth_Level
<src:fragref linkend="geta-body"/>
end Get_Auth_Level;

<src:fragref linkend="proc-init"/> is

<src:fragref linkend="init-vars"/>

begin  -- Init
<src:fragref linkend="init-body"/>
end Init;

begin  -- &pkg;
   Init;
end &pkg;;
</src:fragment>

</section>

</section>

</section>


<!--++++++++++++++++++++++++++++++++-->
<!--        Database section        -->
<!--++++++++++++++++++++++++++++++++-->
<section>
<title>The Configuration Database</title>

<section>
<title>Database Schema</title>

<para>The configuration database schema can be illustrated by the following
SQL <command>CREATE TABLE</command> stataments:</para>

<src:fragment id="schema">
   CREATE TABLE &ctbl;
   (
      name  varchar (&namelen;),
      value text
   );
   CREATE TABLE &atbl;
   (
      name  varchar (&namelen;),
      level integer
   );
</src:fragment>

<para>The two fields contain the name of the configuration value or command
type, such as <literal>username</literal>, <literal>nick</literal>,
<literal>access</literal>, or <literal>help</literal>, and the value of the
configuration item or auth level, such as <literal>Allegra</literal> or
<literal>5</literal>.</para>

</section>

<section id="cfg-value-list">
<title>Use of Values</title>

<para>This table gives the meanings of the configuration values. </para>

<table frame="all">
<title>Configuration Values</title>
<tgroup cols="2">
<colspec colnum="1" align="center"/>
<colspec colnum="2" align="left"/>

<thead>
<row>
<entry>Item&nbsp;Name</entry>
<entry align="center">Value</entry>
</row>
</thead>

<tbody>
<row>
<entry>armpath</entry>
<entry>The pathname of the directory where the ARM (Ada Reference Manual) text
(in HTML format) is located.  Set to null if you do not have the ARM installed
on your system.  Any legal pathname (without any filename portion) is allowed;
the program will need read access to the files in that directory.</entry>
</row>
<row>
<entry>channel</entry>
<entry>The name of the IRC channel where the info-bot is to perform its
function.  Do not include the leading <quote>#</quote> character.  From 1 to
49 characters which obey the IRC rules for valid channel names.  (See <ulink
url="http://www.faqs.org/rfcs/rfc2812.html">RFC 2812</ulink>).</entry>
</row>
<row>
<entry>host</entry>
<entry>The name of the IRC host, or dispatcher, to which the bot should
connect in order to find its home channel.  Used in conjuction with the
<literal>port</literal> value during the connection process.  Any valid
Internet hostname is allowed.</entry>
</row>
<row>
<entry>loglevel</entry>
<entry>The amount of information that is to be included in the log.  The
values are <literal>none</literal> (log nothing), <literal>err</literal> (log
only serious errors), <literal>warn</literal> (log errors and warnings),
<literal>info</literal> (log errors, warnings, and informational messages),
and <literal>dbg</literal> (log all information about program
activity).</entry>
</row>
<row>
<entry>logpath</entry>
<entry>The system pathname of the log file into which log messages are
written.  If the loglevel is <literal>none</literal>, this pathname is
ignored.  Any legal pathname (including the filename portion) is allowed; the
program will need write access to the file.</entry>
</row>
<row>
<entry>nick</entry>
<entry>The IRC nickname the bot is to use when logging in to the server.  From
1 to 9 characters which obey the IRC rules for valid nicknames.  (See <ulink
url="http://www.faqs.org/rfcs/rfc2812.html">RFC 2812</ulink>).</entry>
</row>
<row>
<entry>port</entry>
<entry>Used in conjuction with the <literal>host</literal> value to determine
how to log in to the IRC server.  An integer between 1 and 65535.</entry>
</row>
<row>
<entry>quips</entry>
<entry>Determines whether the program outputs a <quote>quip</quote> (a useless
comment) when it recognizes its nick in a non-comment channel message.  Either
<quote>on</quote> or <quote>off</quote>.</entry>
</row>
<row>
<entry>realname</entry>
<entry>The <quote>real name</quote> to be used by the bot, as passed in the
IRC <command>USER</command> command.  May contain embedded spaces.</entry>
</row>
<row>
<entry>shorthand</entry>
<entry>The shorthand character used to address the bot in the channel.  If
this character is the first one of a channel message, the bot treats it as if
the message had started with its nickname.  Thus, <quote>!help</quote> is
interpreted the same as <quote>&nick;: help</quote>.  We recommend picking
something unusual, that's not likely to be found at the beginning of a message
by accident.</entry>
</row>
<row>
<entry>username</entry>
<entry>The IRC username sent to the server via the <command>USER</command>
command.  Should be a short string with no embedded spaces, similar to a Unix
user ID.</entry>
</row>
</tbody>

</tgroup>
</table>

</section>

<section>
<title>Creating and Initializing the Configuration Database</title>

<para>The configuration values are maintained in a table named &ctbl;, and the
auth levels in a table named &atbl;, within the program's database.  Here is a
shell script that uses the PostgreSQL <command>psql</command> utility to
create and initialize the tables to &prog;'s default values.  This script is
normally run automatically by <ulink url="&instpkg;">the program installation
process</ulink>, which ensures that the database is created before attempting
to create a table within it.</para>

<src:fragment id="init-config">
#!/bin/sh
psql --dbname &progdb; --file - &lt;&lt;eof
<src:fragref linkend="schema"/>
INSERT INTO &ctbl; VALUES ('armpath',   '/usr/share/doc/ada-reference-manual/html/arm95tc1');
INSERT INTO &ctbl; VALUES ('channel',   'Ada');
INSERT INTO &ctbl; VALUES ('host',      'irc.freenode.net');
INSERT INTO &ctbl; VALUES ('loglevel',  'error');
INSERT INTO &ctbl; VALUES ('logpath',   '/var/log/allegra.log');
INSERT INTO &ctbl; VALUES ('nick',      '&nick;');
INSERT INTO &ctbl; VALUES ('port',      '6667');
INSERT INTO &ctbl; VALUES ('quips',     'on');
INSERT INTO &ctbl; VALUES ('realname',  'Allegra InfoBot');
INSERT INTO &ctbl; VALUES ('shorthand', '!');
INSERT INTO &ctbl; VALUES ('username',  'allegra');
INSERT INTO &atbl; VALUES ('access',     10);
INSERT INTO &atbl; VALUES ('fetch',       1);
INSERT INTO &atbl; VALUES ('find',        1);
INSERT INTO &atbl; VALUES ('forget',      5);
INSERT INTO &atbl; VALUES ('help',        1);
INSERT INTO &atbl; VALUES ('list',        1);
INSERT INTO &atbl; VALUES ('quit',        9);
INSERT INTO &atbl; VALUES ('quote',       2);
INSERT INTO &atbl; VALUES ('rename',      5);
INSERT INTO &atbl; VALUES ('set',         5);
INSERT INTO &atbl; VALUES ('stats',       2);
INSERT INTO &atbl; VALUES ('tell',        3);
eof
</src:fragment>

</section>

</section>


</article>
