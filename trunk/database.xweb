<?xml version="1.0" standalone="no"?>
<!DOCTYPE xweb PUBLIC "-//NDW-WMR//DTD DocBook XML V4.1.2-based Extension XWeb V1.0//EN"
                      "file:///opt/litprog/dtd/xweb.dtd" [
<!ENTITY % entities SYSTEM "entities.inc.dtd">
%entities;
<!ENTITY pkg      "&dataname;">
]>

<article xmlns:src="http://nwalsh.com/xmlns/litprog/fragment"
         xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

<!-- Article meta-data -->
<articleinfo>
<title>&prog; Database Access Package</title>

<author>
<firstname>Chip</firstname>
<surname>Richards</surname>
</author>

<address><email>chipr@niestu.com</email></address>
<publisher>
<publishername>NiEstu</publishername>
<address><otheraddr><ulink url="&site;/allegra/"></ulink></otheraddr></address>
</publisher>

<releaseinfo>Version 1.0</releaseinfo>
<date>30 December 2003</date>

<legalnotice>
<para>This code is released under the terms of the <ulink
url="http://www.gnu.org/licenses/gpl.html">GNU General Public License</ulink>,
version 2.</para>
</legalnotice>
</articleinfo>

<!-- The Database task -->
<section id="database-task">
<title>The Database Task</title>

<para>In &prog;, the database task accepts requests for access to the
bot's database.  In &prog;, it simply reports that such requests have been
received, by placing a message on the output queue.</para>

<section>
<title>Database Request Processing Loop</title>
<para>
The heart of the database task is an endless loop.  It removes a request from
the database request queue and examines its <literal>Operation</literal>
field.  If it is a database access request operation, it adds some identifying
text to the data string and places the resulting string on the output queue.
If it is a shutdown request, the loop terminates, which terminates the task.

<src:fragment id="database-loop">
      loop
         Requests.Dequeue (Request);
         <src:fragref linkend="process-request"/>
      end loop;
</src:fragment>

The task spends most of its time sitting on the
<methodname>Dequeue</methodname> statement, waiting for a database access
request to be placed in its queue by <link linkend="command-task">the command
task</link>.
</para>

<section>
<title>Request Processing</title>

<para>All requests except for shutdown lead to some sort of action in the
database.  Most of them have some associated data value.

<src:fragment id="process-request">
   case Request.Operation is

      when Quip_Operation =&gt;
         Output_Request.Operation := &outname;.Message_Operation;
         Output_Request.Destination := Request.Destination;
         Output_Request.Data := Random_Select (Quips_Tbl);
         Output.Requests.Enqueue (Output_Request);

      when Shutdown_Operation =&gt;
         Output_Request.Operation := &outname;.Shutdown_Operation;
         Output_Request.Data := Random_Select (QuitMsg_Tbl);
         Output.Requests.Enqueue (Output_Request);
         exit;

   end case;
</src:fragment>
</para>
</section>

<section>
<title>Random String Selection</title>

<para>This function returns a string selected at random from the given table.
The table is assumed to have an integer field named <quote>nums</quote> which
gives the index of the item, by which it is selected, and a string field named
<quote>msg</quote>, which contains the string value to be returned.  It is not
a particularly fast operation, since it does a database connect and two
selects, but that's the price of fame.

<src:fragment id="func-ranselect">
   function Random_Select (Table : in string) return Unbounded_String is

      use Ada.Numerics.Float_Random, &dbname;;

      Count  : natural;
      Data   : DB_Result;
      Handle : DB_Handle;
      Index  : positive;

   begin  -- Random_Select
      &dbname;.Connect (Handle, Host => "", DB => &cfgname;.Allegra_DB);

      Fetch (Handle, "count(msg)", Table, "", Data);
      if Rows (Data) &gt; 0 then
         Count := Get_Value (Data, 1, "count");
      else
         Count := 0;
      end if;
      if Count &lt; 1 then
         return Null_Unbounded_String;
      end if;

      Index := (integer (float (Count) * Random (Randoms)) mod Count) + 1;
      Fetch (Handle, "msg", Table, "where num=" &amp; positive'Image (Index), Data);
      Disconnect (Handle);
      if Rows (Data) &gt; 0 then
         return To_Unbounded_String (Source =&gt; Get_Value (Data, 1, "msg"));
      else
         return Null_Unbounded_String;
      end if;
   end Random_Select;
</src:fragment>
</para>
</section>

</section>

<section>
<title>Database Task Declarations</title>

<para>
The database loop uses these variables:

<itemizedlist>
<listitem>
<para><literal>Request</literal> - Local variable of the type of the
database-queue entries, used to receive the next item taken from the request
queue.</para>
</listitem>

<listitem>
<para><literal>Output_Request</literal> - Request-queue variable for the
output task.  Used to report requests received by the database task.</para>
</listitem>
</itemizedlist>

<src:fragment id="database-decls">
   Quips_Tbl   : constant string := "quips";
   QuitMsg_Tbl : constant string := "quitmsgs";

   Crash_Request  : &cmdname;.Request_Rec;
   Randoms        : Ada.Numerics.Float_Random.Generator;
   Request        : Request_Rec;
   Output_Request : &outname;.Request_Rec;

   <src:fragref linkend="func-ranselect"/>
</src:fragment>

</para>
</section>

<section>
<title>Database Task Body</title>
<para>
The task's body contains only the processing loop, and its required
declarations:

<src:fragment id="database-task-body">

   task body Database_Task is
<src:fragref linkend="database-decls"/>

   begin  -- Database_Task
      Ada.Numerics.Float_Random.Reset (Randoms);
<src:fragref linkend="database-loop"/>

   exception
      when E: others =>
         Err (Database_Name, "Exception:  " &amp; Ada.Exceptions.Exception_Information (E));
         Crash_Request.Operation := &cmdname;.Crash_Operation;
         Crash_Request.Data      := To_Unbounded_String (Database_Name);
         &cmdname;.Requests.Enqueue (Crash_Request);
   end Database_Task;

</src:fragment>
</para>
</section>

<section>
<title>Database Task Package</title>

<section>
<title>Database Package Body</title>
<para>
For compilation purposes, the task is contained in a package.  The package
body contains only the (anonymous) task object.  The external dependencies
are:

<itemizedlist>
<listitem>
<para><classname>Ada.Strings.Unbounded</classname> - Provides the
<quote>&amp;</quote> operator, used to concatenate the informational message
to the request data..</para>
</listitem>

<listitem>
<para><classname>Output</classname> - Lets the database task see the request
queue of the output task, so it can make output requests.</para>
</listitem>
</itemizedlist>

Visibility is provided to the standard library package via a
<command>use</command> clause; references to items declared in the
<classname>Output</classname> package must be fully qualified.

<src:fragment id="database-pkg-body">
with
   Ada.Exceptions,
   Ada.Numerics.Float_Random,
   Ada.Strings.Unbounded,
   &cfgname;,
   &cmdname;,
   &dbname;,
   &logname;,
   &outname;;

use
   Ada.Strings.Unbounded,
   &logname;;

package body Database is
<src:fragref linkend="database-task-body"/>
end Database;
</src:fragment>
</para>
</section>

<section>
<title>Database Package Spec</title>

<para>The database request queue and its supporting types are declared in the
package spec so they can be used by other packages.</para>

<section>
<title>Database Package Spec Basic Type Declarations</title>
<para>
The spec declares the database-queue request record type and its supporting
operation type.  In &prog;, if the operation field is
<literal>Database_Operation</literal>, the data field is a database access
request; in &prog;, it's any arbitrary text.  The
<literal>Unbounded_String</literal> type of the <literal>Data</literal> field
is defined via <link linkend="database-pkg-spec-context-section">the context
clause</link>.

<src:fragment id="database-basic-types">
   type Operation_Type is ( Shutdown_Operation, Quip_Operation );

   type Request_Rec is record
      Operation:    Operation_Type;
      Destination:  Unbounded_String;
      Data:         Unbounded_String;
   end record;

   task Database_Task;
</src:fragment>
</para>
</section>

<section>
<title>Database Queue Declaration</title>
<para>
The spec instatiates the generic library package <literal>PQueue</literal>
using <literal>Request_Rec</literal> as its data-item type, and then declares
the actual database queue itself, as an item of that new queue type.

<src:fragment id="database-queue-decl">
   package Database_Queue_Pkg is new PQueue (Request_Rec);

   Requests:  Database_Queue_Pkg.Protected_Queue_Type;
</src:fragment></para>
</section>

<section id="database-pkg-spec-context-section">
<title>Database Package Spec Context Clause</title>
<para>
The database task's package spec depends on these two packages:

<itemizedlist>
<listitem>
<para><classname>Ada.Strings.Unbounded</classname>, which provides the
<literal>Unbounded_String</literal> type used for the request record's data.
</para>
</listitem>

<listitem>
<para><classname>PQueue</classname>, a local library package, which is not
defined in this document.  It is a generic package which implements a simple
protected queue type.  The code was adapted from Cohen's book <citetitle
pubwork="book">Ada as a Second Language</citetitle>.</para>
</listitem>
</itemizedlist>

Visibility is provided to the standard library package via a
<command>use</command> clause; references to items declared in the
<classname>PQueue</classname> package (whose instantiation is called
<literal>Database_Queue_Pkg</literal>) must be fully qualified.

<src:fragment id="database-pkg-spec-context">
with
   Ada.Strings.Unbounded,
   PQueue;

use
   Ada.Strings.Unbounded;
</src:fragment>
</para>
</section>

<section>
<title>Package Spec Proper</title>
<para>

The package spec puts together the context clause and the declarations to make
a compilation unit.

<src:fragment id="database-pkg-spec">
<src:fragref linkend="database-pkg-spec-context"/>

package Database is

   &pkg;_Name:  constant string := "&pkg;";

<src:fragref linkend="database-basic-types"/>

<src:fragref linkend="database-queue-decl"/>

end Database;
</src:fragment>
</para>
</section>

</section>
</section>
</section>

</article>
