<?xml version="1.0" standalone="no"?>
<!DOCTYPE xweb PUBLIC "-//NDW-WMR//DTD DocBook XML V4.1.2-based Extension XWeb V1.0//EN"
                      "file:///opt/litprog/dtd/xweb.dtd" [
<!ENTITY % entities SYSTEM "entities.inc.dtd">
%entities;
<!ENTITY pkg      "&dataname;">
]>

<article xmlns:src="http://nwalsh.com/xmlns/litprog/fragment"
         xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

<!-- Article meta-data -->
<articleinfo>
<title>&prog; Database Access Package</title>

<author>
<firstname>Chip</firstname>
<surname>Richards</surname>
</author>

<address><email>chipr@niestu.com</email></address>
<publisher>
<publishername>NiEstu</publishername>
<address><otheraddr><ulink url="&site;/allegra/"></ulink></otheraddr></address>
</publisher>

<releaseinfo>Version 1.0</releaseinfo>
<date>30 December 2003</date>

<legalnotice>
<para>This code is released under the terms of the <ulink
url="http://www.gnu.org/licenses/gpl.html">GNU General Public License</ulink>,
version 2.</para>
</legalnotice>
</articleinfo>

<!-- The Database task -->
<section id="database-task">
<title>The Database Task</title>

<para>In &prog;, the database task accepts requests for access to the
bot's database.  In &prog;, it simply reports that such requests have been
received, by placing a message on the output queue.</para>

<section>
<title>Database Request Processing Loop</title>
<para>
The heart of the database task is an endless loop.  It removes a request from
the database request queue and examines its <literal>Operation</literal>
field.  If it is a database access request operation, it adds some identifying
text to the data string and places the resulting string on the output queue.
If it is a shutdown request, the loop terminates, which terminates the task.

<src:fragment id="database-loop">
      loop
         Requests.Dequeue (Request);
         <src:fragref linkend="process-request"/>
      end loop;
</src:fragment>

The task spends most of its time sitting on the
<methodname>Dequeue</methodname> statement, waiting for a database access
request to be placed in its queue by <link linkend="command-task">the command
task</link>.
</para>

<section>
<title>Request Processing</title>

<para>All requests except for shutdown lead to some sort of action in the
database.  Most of them have some associated data value.

<src:fragment id="process-request">
   case Request.Operation is

      when Access_Operation =&gt;
         Set_Access;

      when AddFactoid_Operation =&gt;
         Add_Factoid;

      when FactoidStats_Operation =&gt;
         Factoid_Stats (S (Request.Key));

      when Fetch_Operation =&gt;
         Fetch_Factoid ("=");

      when Forget_Operation =&gt;
         Forget_Factoid;

      when List_Operation =&gt;
         List_Factoids (S (Request.Data));

      when Quip_Operation =&gt;
         Say (Random_Select (Quips_Tbl), Request.Destination);

      when Quote_Operation =&gt;
         Random_Quote (Quote, Attrib);
         Say (S (Quote), Request.Destination);
         delay 1.5;
         Say (S ("  -- " &amp; Attrib), Request.Destination);

      when RE_Fetch_Operation =&gt;
         Fetch_Factoid ("~*");

      when RE_Tell_Operation =&gt;
         Fetch_Factoid ("~*", Request.Origin);

      when ResetFactoid_Operation =&gt;
         Reset_Factoid;

      when SetAction_Operation =&gt;
         Set_Action;

      when SetFactoid_Operation =&gt;
         Set_Factoid;

      when SetReply_Operation =&gt;
         Set_Reply;

      when Shutdown_Operation =&gt;
         Output_Request.Operation := Output.Shutdown_Operation;
         Output_Request.Data := US (Random_Select (QuitMsg_Tbl));
         &outname;.Requests.Enqueue (Output_Request);
         exit;

      when Stats_Operation =&gt;
         Show_Stats;

      when Tell_Operation =&gt;
         Fetch_Factoid ("=", Request.Origin);

   end case;
</src:fragment>
</para>
</section>

<section>
<title>Random String Selection</title>

<para>This function returns a string selected at random from the given table.
The table is assumed to have an integer field named <quote>nums</quote> which
gives the index of the item, by which it is selected, and a string field named
<quote>msg</quote>, which contains the string value to be returned.  It is not
a particularly fast operation, since it does a database connect and two
selects, but that's the price of fame.

<src:fragment id="func-ranselect">
   function Random_Select (Table : in string) return string is

      use Ada.Numerics.Float_Random, &dbname;;

      Count  : natural;
      Data   : DB_Result;
      Handle : DB_Handle;
      Index  : positive;

   begin  -- Random_Select
      Connect (Handle, Host => "", DB => &cfgname;.Allegra_DB);

      Fetch (Handle, "count(msg)", Table, "", Data);
      if Rows (Data) &gt; 0 then
         Count := Get_Value (Data, 1, "count");
      else
         Count := 0;
      end if;
      if Count &lt; 1 then
         return "";
      end if;

      Index := (integer (float (Count) * Random (Randoms)) mod Count) + 1;
      Fetch (Handle, "msg", Table, "where num=" &amp; positive'Image (Index), Data);
      Disconnect (Handle);
      if Rows (Data) &gt; 0 then
         return Get_Value (Data, 1, "msg");
      else
         return "";
      end if;
   end Random_Select;
</src:fragment>
</para>
</section>

<section>
<title>Random String Selection</title>

<para>This procedure returns a quote selected at random from the quotes table.
It's nearly identical to the <function>Random_Select</function> function,
except that it returns two strings: the quote itself, and the attribution,
which is written separately.

<src:fragment id="proc-ranquote">
   procedure Random_Quote (Quote, Attrib : out Unbounded_String) is

      use Ada.Numerics.Float_Random, &dbname;;

      Count  : natural;
      Data   : DB_Result;
      Handle : DB_Handle;
      Index  : positive;

   begin  -- Random_Quote
      Connect (Handle, Host => "", DB => &cfgname;.Allegra_DB);

      Fetch (Handle, "count(quote)", Quotes_Tbl, "", Data);
      if Rows (Data) &gt; 0 then
         Count := Get_Value (Data, 1, "count");
      else
         Count := 0;
      end if;
      if Count &gt; 0 then
         Index := (integer (float (Count) * Random (Randoms)) mod Count) + 1;
         Fetch (Handle, "quote,attr", Quotes_Tbl, "where num=" &amp; positive'Image (Index), Data);
         if Rows (Data) &gt; 0 then
            Disconnect (Handle);
            Quote  := US (Source =&gt; Get_Value (Data, 1, "quote"));
            Attrib := US (Source =&gt; Get_Value (Data, 1, "attr"));
            return;
         end if;
      end if;
      Disconnect (Handle);
      Quote  := Null_Unbounded_String;
      Attrib := Null_Unbounded_String;
   end Random_Quote;
</src:fragment>
</para>
</section>

<section>
<title>Add a New Factoid Definition</title>

<para>This procedure adds the text associated with a factoid name.  It may
join other definitions for the same factoid already out there.

<src:fragment id="proc-add-factoid">
   procedure Add_Factoid is

      use &dbname;;

      Data   : DB_Result;
      Fact   : string := S (Request.Key);
      Handle : DB_Handle;
      Hits   : natural;

   begin  -- Add_Factoid
      Connect (Handle, Host => "", DB => &cfgname;.Allegra_DB);
      Fetch (Handle, "name", Factoid_Tbl, "where name=" &amp; Escape (To_Lower (Fact)), Data);
      Hits := Rows (Data);
      if Hits = 0 then
         Say ("I don't know a factoid """ &amp; """ yet, but what the heck.", Request.Destination);
         Disconnect (Handle);
         Set_Factoid;
         return;
      end if;

      Statement (Handle, "insert into " &amp; Factoid_Tbl &amp; " (name,value) values (" &amp;
                 To_Lower (Escape (Fact)) &amp; "," &amp; Escape (S (Request.Data)) &amp; ")");
      Say ("Another definition for """ &amp; Fact &amp; """ has been added!", Request.Destination);
      Disconnect (Handle);
   end Add_Factoid;
</src:fragment>
</para>
</section>

<section>
<title>Show Factoid Statistics</title>

<para>This procedure tells the user some statistics about a given factoid.

<src:fragment id="proc-factoid-stats">
   procedure Factoid_Stats (Name : in string) is

      use &dbname;;

      Data   : DB_Result;
      Handle : DB_Handle;
      Msg    : Unbounded_String;

   begin  -- Factoid_Stats
      Connect (Handle, Host => "", DB => &cfgname;.Allegra_DB);
      Fetch (Handle, "*", Factstats_Tbl, "where name=" &amp; Escape (To_Lower (Name)), Data);
      Disconnect (Handle);
      if Rows (Data) &gt; 0 then
         Say ("The factoid named """ &amp; Name &amp; """ was created by " &amp; Get_Value (Data, 1, "creator") &amp;
              " on " &amp; Get_Value (Data, 1, "created") &amp; ".", Request.Destination);
         delay 1.5;
         declare
            Count : string := Get_Value (Data, 1, "acc_count");
         begin
            if Count = "0" then
               Say ("It has never been accessed.", Request.Destination);
            else
               if Count = "1" then
                  Msg := US ("It has been accessed once");
               else
                  Msg := US ("It has been accessed " &amp; Count &amp; " times");
               end if;
               Msg := Msg &amp; ", last by " &amp; Get_Value (Data, 1, "acc_by") &amp;
                      " on " &amp; Get_Value (Data, 1, "acc_last") &amp; ".";
               Say (S (Msg), Request.Destination);
            end if;
         end;
      else
         Say ("I can't seem to locate a factoid named """ &amp; Name &amp; """, sorry.", Request.Destination);
      end if;
   end Factoid_Stats;
</src:fragment>
</para>
</section>

<section>
<title>Fetch Factoid</title>

<para>This procedure returns the text associated with a factoid name.  The
result could be several lines, in which case an appropriate delay is done
between each line.

<src:fragment id="proc-fetch-factoid">
   procedure Fetch_Factoid (Op : in string;   From : in Unbounded_String := Null_Unbounded_String) is

      use &dbname;;

      Data   : DB_Result;
      AccCnt : DB_Result;
      Handle : DB_Handle;
      Hits   : natural;

   begin  -- Fetch_Factoid
      if Length (Request.Data) &lt; 1 then
         Say (Random_Select (Quips_Tbl), Request.Destination);
         return;
      end if;

      Connect (Handle, Host => "", DB => &cfgname;.Allegra_DB);

      Fetch (Handle, "name,value", Factoid_Tbl, "where name" &amp; Op &amp; Escape (To_Lower (S (Request.Data))), Data);
      Hits := Rows (Data);
      if Hits &gt; 0 then
         if From /= Null_Unbounded_String then
            if From = Request.Origin then
               Say ("You wanted to know:", Request.Destination);
            else
               Say (S (From) &amp; " wanted me to tell you:", Request.Destination);
            end if;
         end if;
         declare
            Key : string := Get_Value (Data, 1, "name");
         begin
            for Row in 2 .. Hits loop
               if Get_Value (Data, Row, "name") /= Key then
                  Say ("""" &amp; S (Request.Data) &amp; """ matches more than one factoid ...", Request.Destination);
                  List_Factoids (S (Request.Data));
                  Disconnect (Handle);
                  return;
               end if;
            end loop;
            Fetch (Handle, "acc_count", Factstats_Tbl, "where name='" &amp; Key &amp; "'", AccCnt);
            Statement (Handle, "update " &amp; Factstats_Tbl &amp;
                       " set acc_count=" &amp; natural'Image (Get_Value (AccCnt, 1, "acc_count") + 1) &amp;
                       ",acc_last='now',acc_by=" &amp; Escape (To_Lower (S (Request.Origin))) &amp;
                       " where name='" &amp; Key &amp; "'");
            Disconnect (Handle);
         end;
         for Row in 1 .. Hits loop
            if Row = 1 then
               Say (Get_Value (Data, Row, "name") &amp; ":  " &amp; Get_Value (Data, Row, "value"), Request.Destination);
            else
               Say (Get_Value (Data, Row, "value"), Request.Destination);
            end if;
            if Hits &gt; 1 and then Row /= Hits then
               delay 1.0;
               Say (" - or -", Request.Destination);
               delay 1.0;
            end if;
         end loop;
         if From /= Null_Unbounded_String and then From /= Request.Origin then
            Say ("I told " &amp; S (Request.Destination) &amp; natural'Image (Hits) &amp; " line(s).", Request.Origin);
         end if;
      else
         Disconnect (Handle);
         if From /= Null_Unbounded_String then
            Say (S (From) &amp; " asked me to tell you about """ &amp; S (Request.Data) &amp; """, but I couldn't find it.", Request.Destination);
            Say ("Regrettably, I couldn't find """ &amp; S (Request.Data) &amp; """ to tell " &amp; S (From), Request.Origin);
         else
            Say ("Sorry, I couldn't find anything that matches """ &amp; S (Request.Data) &amp; """", Request.Destination);
         end if;
      end if;
   end Fetch_Factoid;
</src:fragment>
</para>
</section>

<section>
<title>Forget Factoid</title>

<para>This procedure deletes the text of a factoid.  Yes, all of it.  A future
enhancement would be to move it to a "forgotten" table before deleting it.
Another auth check is done if the changer is not the creator, because that
requires a higher auth level than the one already verified by the
<literal>&cmdname;</literal> task.

<src:fragment id="proc-forget-factoid">
   procedure Forget_Factoid is

      use &dbname;;

      Data   : DB_Result;
      Fact   : string := S (Request.Key);
      Handle : DB_Handle;
      Count  : natural;
      Msg    : Unbounded_String;

   begin  -- Forget_Factoid
      Connect (Handle, Host => "", DB => &cfgname;.Allegra_DB);
      Fetch (Handle, "creator", Factstats_Tbl, "where name=" &amp; Escape (To_Lower (Fact)), Data);
      if Rows (Data) = 0 then
         Say ("I don't seem to know a factoid """ &amp; Fact &amp; """, so nothing was forgotten.",
              Request.Destination);
         return;
      end if;

      if Is_Owner_Operator (S (Request.Origin), Get_Value (Data, 1, "creator")) then
         Fetch (Handle, "count(name)", Factoid_Tbl, "where name=" &amp; Escape (To_Lower (Fact)), Data);
         if Rows (Data) &gt; 0 then
            Count := Get_Value (Data, 1, "count");
         else
            Count := 1;  -- assuming
         end if;
         Statement (Handle, "delete from " &amp; Factoid_Tbl   &amp; " where name=" &amp; Escape (To_Lower (Fact)));
         Statement (Handle, "delete from " &amp; Factstats_Tbl &amp; " where name=" &amp; Escape (To_Lower (Fact)));
         Msg := US ("I've forgotten ");
         if Count &gt; 1 then
            Msg := Msg &amp; "all" &amp; natural'Image (Count) &amp; " definitions of";
         end if;
         Say (S (Msg &amp; " factoid """ &amp; Fact &amp; """!"), Request.Destination);
      end if;

      Disconnect (Handle);
   end Forget_Factoid;
</src:fragment>
</para>
</section>

<section>
<title>List Factoids</title>

<para>This procedure lists factoid names, either those matching a given
pattern, or all of them.  Splits the reply up to ensure that it does not
exceed the IRC message-size limit.

<src:fragment id="proc-list-factoids">
   procedure List_Factoids (Pat : string) is

      use &dbname;;

      Data   : DB_Result;
      Handle : DB_Handle;
      Hits   : natural;
      Msg    : Unbounded_String;
      First  : boolean;

   begin  -- List_Factoids
      Connect (Handle, Host => "", DB => &cfgname;.Allegra_DB);

      Fetch (Handle, "distinct name", Factoid_Tbl, "where name ~* " &amp; Escape (To_Lower (Pat)) &amp; " order by name", Data);
      Disconnect (Handle);
      Hits := Rows (Data);
      if Hits &gt; 0 then
         First := true;
         for Row in 1 .. Hits loop
            if Row = 1 then
               if Pat = "." then
                  Msg := US ("All factoids:  ");
               else
                  Msg := US ("Factoids matching """ &amp; Pat &amp; """:  ");
               end if;
            end if;
            declare
               Name : string := Get_Value (Data, Row, "name");
            begin
               if Length (Msg) + Name'Length &gt; Message_Limit then
                  if Length (Msg) &gt; 0 then
                     Say (S (Msg), Request.Destination);
                  end if;
                  Msg := US (" - and:  ");
                  delay 2.0;
                  First := true;
               end if;
               if First then
                  Append (Msg, Name);
                  First := false;
               else
                  Append (Msg, ", " &amp; Name);
               end if;
            end;
         end loop;
         if Length (Msg) &gt; 0 then
            Say (S (Msg), Request.Destination);
         end if;
      else
         Say ("No factoids match """ &amp; Pat &amp; """", Request.Destination);
      end if;
   end List_Factoids;
</src:fragment>
</para>
</section>

<section>
<title>Reset Factoid</title>

<para>This procedure changes the text of a factoid to a new value.  Another
auth check is done if the changer is not the creator, because that requires a
higher auth level than the one already verified by the
<literal>&cmdname;</literal> task.

<src:fragment id="proc-reset-factoid">
   procedure Reset_Factoid is

      use &dbname;;

      Data   : DB_Result;
      Fact   : string := S (Request.Key);
      Handle : DB_Handle;

   begin  -- Reset_Factoid
      Connect (Handle, Host => "", DB => &cfgname;.Allegra_DB);
      Fetch (Handle, "creator", Factstats_Tbl, "where name=" &amp; Escape (To_Lower (Fact)), Data);
      if Rows (Data) = 0 then
         Say ("I don't seem to know a factoid """ &amp; Fact &amp;
              """ ... if you want to set it, just do ""factoid is definition"".",
              Request.Destination);
         return;
      end if;

      if Is_Owner_Operator (S (Request.Origin), Get_Value (Data, 1, "creator")) then
         Statement (Handle, "delete from " &amp; Factoid_Tbl &amp; " where name=" &amp; Escape (To_Lower (Fact)));
         Statement (Handle, "insert into " &amp; Factoid_Tbl &amp; " (name,value) values (" &amp;
                    Escape (To_Lower (Fact)) &amp; "," &amp; Escape (S (Request.Data)) &amp; ")");
         Say ("I've changed factoid """ &amp; Fact &amp; """!", Request.Destination);
      end if;

      Disconnect (Handle);
   end Reset_Factoid;
</src:fragment>
</para>
</section>

<section>
<title>Set Access Level</title>

<para>This function sets a user's access level.
<src:fragment id="proc-set-access">
   procedure Set_Access is

      use &dbname;;

      Data   : DB_Result;
      Handle : DB_Handle;
      Hits   : natural;

   begin  -- Set_Access
      Connect (Handle, Host => "", DB => &cfgname;.Allegra_DB);

      Fetch (Handle, "name", UserLvl_Tbl, "where name = '" &amp; To_Lower (S (Request.Key)) &amp; "'", Data);
      Hits := Rows (Data);
      if Hits &gt; 0 then
         Statement (Handle, "update " &amp; UserLvl_Tbl &amp; " set level=" &amp; S (Request.Data) &amp;
                            "where name=" &amp; Escape (To_Lower (S (Request.Key))));
         Say ("Access level for " &amp; To_Lower (S (Request.Key)) &amp; " updated to " &amp; S (Request.Data), Request.Origin);
      else
         Statement (Handle, "insert into " &amp; UserLvl_Tbl &amp; " (name,level) values (" &amp; 
                            Escape (To_Lower (S (Request.Key))) &amp; "," &amp; S (Request.Data) &amp; ")");
         Say ("Usermask " &amp; To_Lower (S (Request.Key)) &amp; " added with level " &amp; S (Request.Data), Request.Origin);
      end if;
      Disconnect (Handle);
      &authname;.Init;
   end Set_Access;
</src:fragment>
</para>
</section>

<section>
<title>Set Action</title>

<para>This procedure sets the text associated with an action "factoid".

<src:fragment id="proc-set-action">
   procedure Set_Action is

      use &dbname;;

      Handle : DB_Handle;

   begin  -- Set_Action
      Say ("The set-action command is not yet implemented.", Request.Destination);
   end Set_Action;
</src:fragment>
</para>
</section>

<section>
<title>Set Factoid</title>

<para>This procedure sets the text associated with a factoid name.  The
factoid must not already exist.

<src:fragment id="proc-set-factoid">
   procedure Set_Factoid is

      use &dbname;;

      Data   : DB_Result;
      Fact   : string := S (Request.Key);
      Handle : DB_Handle;
      Hits   : natural;
      Msg    : Unbounded_String;

   begin  -- Set_Factoid
      Connect (Handle, Host => "", DB => &cfgname;.Allegra_DB);
      Fetch (Handle, "name", Factoid_Tbl, "where name=" &amp; Escape (To_Lower (Fact)), Data);
      Hits := Rows (Data);
      if Hits = 0 then
         Statement (Handle, "insert into " &amp; Factoid_Tbl &amp; " (name,value) values (" &amp;
                    To_Lower (Escape (Fact)) &amp; "," &amp; Escape (S (Request.Data)) &amp; ")");
         Statement (Handle, "insert into " &amp; Factstats_Tbl &amp; " (name,creator) values (" &amp;
                    To_Lower (Escape (Fact)) &amp; "," &amp; Escape (To_Lower (S (Request.Origin))) &amp; ")");
         Say ("""" &amp; Fact &amp; """ has been added!", Request.Destination);
      else
         if Hits = 1 then
            Msg := US ("I'm sorry, there is already a definition");
         else
            Msg := US ("I'm sorry, there are already" &amp; natural'Image (Hits) &amp; " definitions");
         end if;
         Msg := Msg &amp; " for """ &amp; Fact &amp;
              """.  Do a reset (""no, factoid is definition"") if you want to replace ";
         if Hits = 1 then
            Msg := Msg &amp; "it, or an add (""factoid is also definition"") to add a second definition.";
         else
            Msg := Msg &amp; "them all, or an add (""factoid is also definition"") to add another.";
         end if;
         Say (S (Msg), Request.Destination);
      end if;
      Disconnect (Handle);
   end Set_Factoid;
</src:fragment>
</para>
</section>

<section>
<title>Set Reply</title>

<para>This procedure sets the text associated with a reply "factoid".

<src:fragment id="proc-set-reply">
   procedure Set_Reply is

      use &dbname;;

      Handle : DB_Handle;

   begin  -- Set_Reply
      Say ("The set-reply command is not yet implemented.", Request.Destination);
   end Set_Reply;
</src:fragment>
</para>
</section>

<section>
<title>Show Statistics</title>

<para>This procedure tells the user some database statistics.

<src:fragment id="proc-show-stats">
   procedure Show_Stats is

      use &dbname;;

      Data   : DB_Result;
      Handle : DB_Handle;

   begin  -- Show_Stats
      &dbname;.Connect (Handle, Host => "", DB => &cfgname;.Allegra_DB);
      Fetch (Handle, "count(distinct name)", Factoid_Tbl, "", Data);
      Disconnect (Handle);
      if Rows (Data) &gt; 0 then
         Say ("I currently know " &amp; Get_Value (Data, 1, "count") &amp; " factoids.", Request.Destination);
      end if;
   end Show_Stats;
</src:fragment>
</para>
</section>

<section>
<title>Say a String</title>
<para>

<src:fragment id="proc-say">
   procedure Say (Msg : in string;  To : in Unbounded_String) is
   begin  -- Say
      Output_Request.Operation := Output.Message_Operation;
      Output_Request.Destination := To;
      Output_Request.Data := US (Msg);
      &outname;.Requests.Enqueue (Output_Request);
   end Say;
</src:fragment>
</para>
</section>

<section>
<title>Check Owner/Operator Authorization</title>
<para>

<src:fragment id="func-owner-op">
   function Is_Owner_Operator (Who     : in string;
                               Creator : in string) return boolean is
   begin  -- Is_Owner_Operator
      if Creator /= Who then
         if &authname;.Level (Request.Requestor) &lt; &authname;.Bot_Operator_Level then
            Say ("I'm sorry " &amp; Who &amp; ", that factoid was created by " &amp;
                 Creator &amp; " and I can't let you change it.  Check with " &amp;
                 Creator &amp; " or my operator to get it changed.", Request.Destination);
            return false;
         end if;
      end if;
      return true;
   end Is_Owner_Operator;
</src:fragment>
</para>
</section>

</section>

<section>
<title>Database Task Declarations</title>

<para>
The database loop uses these variables:

<itemizedlist>
<listitem>
<para><literal>Request</literal> - Local variable of the type of the
database-queue entries, used to receive the next item taken from the request
queue.</para>
</listitem>

<listitem>
<para><literal>Output_Request</literal> - Request-queue variable for the
output task.  Used to report requests received by the database task.</para>
</listitem>
</itemizedlist>

<src:fragment id="database-decls">
   function S (Source : in Ada.Strings.Unbounded.Unbounded_String) return string
     renames Ada.Strings.Unbounded.To_String;

   function US (Source : in string) return Ada.Strings.Unbounded.Unbounded_String
     renames Ada.Strings.Unbounded.To_Unbounded_String;

   Message_Limit : constant := 256;

   Factoid_Tbl   : constant string := "factoids";
   Factstats_Tbl : constant string := "factstats";
   Quips_Tbl     : constant string := "quips";
   QuitMsg_Tbl   : constant string := "quitmsgs";
   Quotes_Tbl    : constant string := "quotes";
   UserLvl_Tbl   : constant string := "usrlevels";

   Attrib         : Unbounded_String;
   Crash_Request  : &cmdname;.Request_Rec;
   Quote          : Unbounded_String;
   Randoms        : Ada.Numerics.Float_Random.Generator;
   Request        : Request_Rec;
   Output_Request : &outname;.Request_Rec;


   <src:fragref linkend="proc-say"/>

   <src:fragref linkend="func-owner-op"/>

   <src:fragref linkend="func-ranselect"/>

   <src:fragref linkend="proc-ranquote"/>

   <src:fragref linkend="proc-set-factoid"/>

   <src:fragref linkend="proc-add-factoid"/>

   <src:fragref linkend="proc-factoid-stats"/>

   <src:fragref linkend="proc-forget-factoid"/>

   <src:fragref linkend="proc-list-factoids"/>

   <src:fragref linkend="proc-fetch-factoid"/>

   <src:fragref linkend="proc-reset-factoid"/>

   <src:fragref linkend="proc-set-access"/>

   <src:fragref linkend="proc-set-action"/>

   <src:fragref linkend="proc-set-reply"/>

   <src:fragref linkend="proc-show-stats"/>
</src:fragment>

</para>
</section>

<section>
<title>Database Task Body</title>
<para>
The task's body contains only the processing loop, and its required
declarations:

<src:fragment id="database-task-body">

   task body Database_Task is
<src:fragref linkend="database-decls"/>

   begin  -- Database_Task
      Ada.Numerics.Float_Random.Reset (Randoms);
<src:fragref linkend="database-loop"/>

   exception
      when E: others =>
         Err (Database_Name, "Exception:  " &amp; Ada.Exceptions.Exception_Information (E));
         Crash_Request.Operation := &cmdname;.Crash_Operation;
         Crash_Request.Data      := US (Database_Name);
         &cmdname;.Requests.Enqueue (Crash_Request);
   end Database_Task;

</src:fragment>
</para>
</section>

<section>
<title>Database Task Package</title>

<section>
<title>Database Package Body</title>
<para>
For compilation purposes, the task is contained in a package.  The package
body contains only the (anonymous) task object.  The external dependencies
are:

<itemizedlist>
<listitem>
<para><classname>Ada.Strings.Unbounded</classname> - Provides the
<quote>&amp;</quote> operator, used to concatenate the informational message
to the request data..</para>
</listitem>

<listitem>
<para><classname>Output</classname> - Lets the database task see the request
queue of the output task, so it can make output requests.</para>
</listitem>
</itemizedlist>

Visibility is provided to the standard library package via a
<command>use</command> clause; references to items declared in the
<classname>Output</classname> package must be fully qualified.

<src:fragment id="database-pkg-body">
with
   Ada.Characters.Handling,
   Ada.Exceptions,
   Ada.Numerics.Float_Random,
   Ada.Strings.Unbounded,
   &authname;,
   &cfgname;,
   &cmdname;,
   &dbname;,
   &logname;,
   &outname;;

use
   Ada.Characters.Handling,
   Ada.Strings.Unbounded,
   &logname;;

package body Database is
<src:fragref linkend="database-task-body"/>
end Database;
</src:fragment>
</para>
</section>

<section>
<title>Database Package Spec</title>

<para>The database request queue and its supporting types are declared in the
package spec so they can be used by other packages.</para>

<section>
<title>Database Package Spec Basic Type Declarations</title>
<para>
The spec declares the database-queue request record type and its supporting
operation type.  In &prog;, if the operation field is
<literal>Database_Operation</literal>, the data field is a database access
request; in &prog;, it's any arbitrary text.  The
<literal>Unbounded_String</literal> type of the <literal>Data</literal> field
is defined via <link linkend="database-pkg-spec-context-section">the context
clause</link>.

<src:fragment id="database-basic-types">
   type Operation_Type is ( Access_Operation, AddFactoid_Operation,
                            FactoidStats_Operation, Fetch_Operation,
                            Forget_Operation, List_Operation, Quip_Operation,
                            Quote_Operation, RE_Fetch_Operation,
                            RE_Tell_Operation, ResetFactoid_Operation,
                            SetAction_Operation, SetFactoid_Operation,
                            SetReply_Operation, Shutdown_Operation,
                            Stats_Operation, Tell_Operation );

   type Request_Rec is record
      Operation:    Operation_Type;
      Destination:  Unbounded_String;
      Origin:       Unbounded_String;
      Requestor:    Unbounded_String;
      Key:          Unbounded_String;
      Data:         Unbounded_String;
   end record;

   task Database_Task;
</src:fragment>
</para>
</section>

<section>
<title>Database Queue Declaration</title>
<para>
The spec instatiates the generic library package <literal>PQueue</literal>
using <literal>Request_Rec</literal> as its data-item type, and then declares
the actual database queue itself, as an item of that new queue type.

<src:fragment id="database-queue-decl">
   package Database_Queue_Pkg is new PQueue (Request_Rec);

   Requests:  Database_Queue_Pkg.Protected_Queue_Type;
</src:fragment></para>
</section>

<section id="database-pkg-spec-context-section">
<title>Database Package Spec Context Clause</title>
<para>
The database task's package spec depends on these two packages:

<itemizedlist>
<listitem>
<para><classname>Ada.Strings.Unbounded</classname>, which provides the
<literal>Unbounded_String</literal> type used for the request record's data.
</para>
</listitem>

<listitem>
<para><classname>PQueue</classname>, a local library package, which is not
defined in this document.  It is a generic package which implements a simple
protected queue type.  The code was adapted from Cohen's book <citetitle
pubwork="book">Ada as a Second Language</citetitle>.</para>
</listitem>
</itemizedlist>

Visibility is provided to the standard library package via a
<command>use</command> clause; references to items declared in the
<classname>PQueue</classname> package (whose instantiation is called
<literal>Database_Queue_Pkg</literal>) must be fully qualified.

<src:fragment id="database-pkg-spec-context">
with
   Ada.Strings.Unbounded,
   PQueue;

use
   Ada.Strings.Unbounded;
</src:fragment>
</para>
</section>

<section>
<title>Package Spec Proper</title>
<para>

The package spec puts together the context clause and the declarations to make
a compilation unit.

<src:fragment id="database-pkg-spec">
<src:fragref linkend="database-pkg-spec-context"/>

package Database is

   &pkg;_Name:  constant string := "&pkg;";

<src:fragref linkend="database-basic-types"/>

<src:fragref linkend="database-queue-decl"/>

end Database;
</src:fragment>
</para>
</section>

</section>
</section>
</section>

</article>
