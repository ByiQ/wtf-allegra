<?xml version="1.0" standalone="no"?>
<!DOCTYPE xweb PUBLIC "-//NDW-WMR//DTD DocBook XML V4.1.2-based Extension XWeb V1.0//EN"
                      "file:///opt/litprog/dtd/xweb.dtd" [
<!ENTITY svc      "authorization">
<!ENTITY % entities SYSTEM "entities.inc.dtd">
%entities;
<!ENTITY pkg      "&authname;">
]>

<article xmlns:src="http://nwalsh.com/xmlns/litprog/fragment"
         xmlns:xsl="http://www.w3.org/1999/XSL/Transform">


<!-- Article meta-data -->
<articleinfo>
<title>&prog; Authorization Services</title>

<author>
<firstname>Chip</firstname>
<surname>Richards</surname>
</author>

<address><email>chipr@niestu.com</email></address>
<publisher>
<publishername>NiEstu</publishername>
<address><otheraddr><ulink url="&site;/allegra/"></ulink></otheraddr></address>
</publisher>

<releaseinfo>Version 1.0</releaseinfo>
<date>7 March 2004</date>

<legalnotice>
<para>This code is released under the terms of the <ulink
url="http://www.gnu.org/licenses/gpl.html">GNU General Public License</ulink>,
version 2.</para>
</legalnotice>
</articleinfo>


<!--++++++++++++++++++++++++++++++++-->
<!--            API  section        -->
<!--++++++++++++++++++++++++++++++++-->
<section>
<title>API</title>

<section>
<title>Overview</title>

<para>The &authname; package provides authorization services for &prog;, to
ensure that operations are not performed by entities that are not allowed to
do them.  This may sound a bit heavy-handed, but IRC is a hotbed of abuse and
chaos, and without some degree of protection, any bot is likely to be
exploited.  Under the current model, the operator can configure the bot to be
completely open to all users if so desired.</para>

<para>Note that this package currently uses GNAT-specific library packages,
and so is not totally portable.  The rest of &prog; probably isn't all that
portable either, but this code is especially so.</para>

</section>

<section>
<title>Service Details</title>

<para>Currently, the package offers two routines:</para>

<itemizedlist>
<listitem>
<para><function>Match</function> - A function which accepts two
<quote>msgto</quote> strings, one of which is taken as a user, and one a mask.
Returns true if the user matches the mask.</para>
</listitem>

<listitem>
<para><function>Permitted</function> - A function which accepts a command type
and a <quote>msgto</quote> string, which may contain nickname, username, and
hostname fields.  It returns true if that user is authorized to execute that
command, false if not.  Uses the <function>Match</function> function, the
command authorization level configuration table, and the mask auth level table
to determine authorization.</para>
</listitem>
</itemizedlist>

<src:fragment id="func-level">
   function Level (Who:  in Unbounded_String)
   return &cfgname;.Auth_Level
</src:fragment>

<src:fragment id="func-match">
   function Match (Who:  in Unbounded_String;
                   Mask: in Unbounded_String)
   return Authorization
</src:fragment>

<src:fragment id="func-permitted">
   function Permitted (Who:  in Unbounded_String;
                       Cmd:  in &cfgname;.Command_Type)
   return Authorization
</src:fragment>

<src:fragment id="proc-init">
   procedure Init
</src:fragment>

<para>
</para>

</section>

</section>


<!--++++++++++++++++++++++++++++++++-->
<!--    Implementation section      -->
<!--++++++++++++++++++++++++++++++++-->
<section>
<title>Implementation</title>

<para></para>

<section>
<title>Package Declarations</title>

<para></para>

<src:fragment id="auth-decls">
   Default_Auth_Level : constant := 1;

   type User_Rec;
   type User_Ptr is access User_Rec;
   type User_Rec is record
      ID:     Unbounded_String;
      Level:  &cfgname;.Auth_Level;
      Next:   User_Ptr;
   end record;

   procedure Free is new Ada.Unchecked_Deallocation (User_Rec, User_Ptr);   

   User_Head:  User_Ptr := null;
   User_Tail:  User_Ptr;
</src:fragment>
</section>

<section>
<title>Initialization</title>

<section>
<title>Initialization Code</title>

<para>The <function>Init</function> procedure is called at package
initialization time, and can be called at any time during execution.  It
caches the user auth levels in memory as a linked list.  It starts by freeing
the existing list, if there is one, then fetches the user access-level table
from the database and builds a list to hold it.</para>

<src:fragment id="init-body">
   while User_Head /= null loop
      Next := User_Head.Next;
      Free (User_Head);
   end loop;

   DB.Connect (Handle, Host => "", DB => &cfgname;.Allegra_DB);
   DB.Fetch (Handle, "*", &cfgname;.UserLvl_Tbl, "", Auth_Data);
   for Row in 1 .. DB.Rows (Auth_Data) loop
      declare
         UName    : string := DB.Get_Value (Auth_Data, Row, "name");
         Name     : Unbounded_String := To_Unbounded_String (UName);
         Level    : &cfgname;.Auth_Level := DB.Get_Value (Auth_Data, Row, "level");
         New_User : User_Ptr := new User_Rec'(ID =&gt; Name, Level =&gt; Level, Next =&gt; null);
      begin
         if User_Head = null then
            User_Head := New_User;
         else
            User_Tail.Next := New_User;
         end if;
         User_Tail := New_User;
      end;
   end loop;
   DB.Disconnect (Handle);
</src:fragment>
</section>

<section>
<title>Initialization Variables</title>
<para>The <function>Init</function> procedure uses these variables during its
processing:</para>

<src:fragment id="init-vars">
   Handle    : DB.DB_Handle;
   Auth_Data : DB.DB_Result;
   Next      : User_Ptr;
</src:fragment>

<itemizedlist>
<listitem>
<para><varname>Handle</varname> - A database handle that is used to fetch data
from the database server.</para>
</listitem>

<listitem>
<para><varname>Auth_Data</varname> - A database result handle that is used to
fetch the user authorization levels.</para>
</listitem>
</itemizedlist>
</section>

</section>

<section>
<title>User Mask Matching</title>

<para>This is a general-purpose function which simply does a wildcard match of
the given user ID (expressed in the <quote>msgto</quote> format of
<literal>nick!user@host</literal>) with a mask, also in the same format and
which may contain the wildcard characters <quote>?</quote> and
<quote>*</quote>, which match exactly one character, or zero or more
characters respectively.</para>

<para>The function begins by splitting both the user ID and the mask into
their component parts.  It then compares each part in turn, and returns false
at the first mistmatch; if no mistmatches are detected, it returns
true.</para>

<section>
<title>Authorization-Level Function</title>

<para>This function returns the numeric auth level for a given user ID.  If
the ID matches a mask in the user-level table, that level is returned;
otherwise, it returns the default level.</para>

<src:fragment id="level-body">
   User := User_Head;
   while User /= null loop
      exit when Match (Who, User.ID) = Succeeded;
      User := User.Next;
   end loop;

   if User = null then
      return Default_Auth_Level;
   else
      return User.Level;
   end if;
</src:fragment>
</section>

<src:fragment id="match-body">
   &ircname;.Parse_MsgTo (Who,  UserID);
   &ircname;.Parse_MsgTo (Mask, Check);
   if not Match (To_String (UserID.Nick), Compile (To_String (Check.Nick), Glob =&gt; true, Case_Sensitive =&gt; false)) then
      return Fail_Nick;
   end if;
   if not Match (To_String (UserID.User), Compile (To_String (Check.User), Glob =&gt; true, Case_Sensitive =&gt; false)) then
      return Fail_User;
   end if;
   if not Match (To_String (UserID.Host), Compile (To_String (Check.Host), Glob =&gt; true, Case_Sensitive =&gt; false)) then
      return Fail_Host;
   end if;
   return Succeeded;
</src:fragment>
</section>

<section>
<title>Checking Authorization</title>

<para>This function checks a given user against a given command, and answers
the simple question, can s/he do it?  It does this by calling the
<function>Level</function> function to get the user's auth level.  The level
is checked against the command's configured auth level; if the user's level is
equal to or greater than the command's level, then the function returns
<literal>Succeeded</literal>.  If not, it returns
<literal>Fail_Nick</literal>, which is really sort of a violation of the type,
since that's supposed to mean that only the nick didn't match.  But since the
user ID is checked against every mask in the user auth table before failure is
declared, it's hard to say exactly what the failure was, so
<literal>Fail_Nick</literal> is used as a sort of catch-all.</para>

<src:fragment id="permitted-body">
   if Level (Who) &gt;= &cfgname;.Get_Auth_Level (Cmd) then
      return Succeeded;
   else
      return Fail_Nick;
   end if;
</src:fragment>
</section>

</section>


<!--++++++++++++++++++++++++++++++++-->
<!--        Packaging section       -->
<!--++++++++++++++++++++++++++++++++-->
<section>
<title>Packaging</title>

<section>
<title>The Package Spec</title>

<section>
<title>Package Spec Context Clause</title>

<para>The package spec's context clause imports these packages:</para>

<itemizedlist>
<listitem>
<para><classname>Ada.Strings.Unbounded</classname> - For the data type
<literal>Unbounded_String</literal>, which is the type of the msgto string as
provided by the &ircname; package.  Visibility for the unbounded-string
services is provided via a <command>use</command> clause.
</para>
</listitem>

<listitem>
<para><classname>&cfgname;</classname> - For access to configuration
information.</para>
</listitem>

<listitem>
<para><classname>&dbname;</classname> - For database access services.</para>
</listitem>
</itemizedlist>

<src:fragment id="spec-context">
with
   Ada.Strings.Unbounded,
   &cfgname;;

use
   Ada.Strings.Unbounded;
</src:fragment>

</section>

<para>The package spec declares the <function>Match</function> and
<function>Permitted</function> functions, and the <function>Init</function>
procedure.
</para>

<src:fragment id="auth-pkg-spec">

<src:fragref linkend="spec-context"/>

package &pkg; is

   Bot_Operator_Level : constant := 10;

   type Authorization is (Succeeded, Fail_Nick, Fail_User, Fail_Host, Fail_Level);

   <src:fragref linkend="func-level"/>;

   <src:fragref linkend="func-match"/>;

   <src:fragref linkend="func-permitted"/>;

   <src:fragref linkend="proc-init"/>;

end &pkg;;
</src:fragment>

</section>

<section>
<title>The Package Body</title>

<para>The package body assembles the various pieces of service code into a
compilation unit.</para>

<section>
<title>Package Body Context Clause</title>

<para>The package body uses several Ada-standard and application-specific
packages for their types and subroutines.  No global <literal>use</literal>
clause is specified; each block declares which package(s) it will be
using.</para>

<itemizedlist>
<listitem>
<para><classname>Ada.Calendar</classname> - Used when generating the
timestamps that are attached to each logged message.</para>
</listitem>

<listitem>
<para><classname>Ada.Exceptions</classname> - Used in the
<function>Init</function> procedure's exception handler, to print the name of
an unexpected exception.</para>
</listitem>

<listitem>
<para><classname>Ada.Integer_Text_IO</classname> - Used when generating the
timestamps that are attached to each logged message, to format the numeric
date and time values.</para>
</listitem>

<listitem>
<para><classname>Ada.Strings.Fixed</classname> - Needed for the
<function>Head</function> function, used to pad task names to a fixed width in
the log file.</para>
</listitem>

<listitem>
<para><classname>Ada.Strings.Unbounded</classname> - The log-file pathname is
stored as an unbounded string, so the type and conversion routines are used to
convert them to and from standard strings.</para>
</listitem>

<listitem>
<para><classname>Ada.Text_IO</classname> - Used to create/open/close the log
file(s), and to write messages to them.</para>
</listitem>

<listitem>
<para><classname>&cfgname;</classname> - Provides access to the configuration
database, from which the logging services fetch the log level and log-file
pathname.</para>
</listitem>
</itemizedlist>

<src:fragment id="body-context">
with
   Ada.Unchecked_Deallocation,
   Ada.Strings.Unbounded,
   Ada.Text_IO,
   GNAT.Regexp,
   &cfgname;,
   &ircname;,
   &dbname;;
</src:fragment>

</section>

<section>
<title>Compilation Unit</title>

<para>The body imports the same external package as the spec, but uses
procedures and functions from it rather than types.</para>

<src:fragment id="auth-pkg-body">

<src:fragref linkend="body-context"/>

package body &pkg; is

<src:fragref linkend="auth-decls"/>

<src:fragref linkend="func-level"/> is

   User : User_Ptr;

begin  -- Level
   <src:fragref linkend="level-body"/>
end Level;

<src:fragref linkend="func-match"/> is

   use GNAT.Regexp;

   Check  : &ircname;.MsgTo_Rec;
   UserID : &ircname;.MsgTo_Rec;

begin  -- Match
   <src:fragref linkend="match-body"/>
end Match;

<src:fragref linkend="func-permitted"/> is
begin  -- Permitted
   <src:fragref linkend="permitted-body"/>
end Permitted;

<src:fragref linkend="proc-init"/> is

<src:fragref linkend="init-vars"/>

begin  -- Init
   <src:fragref linkend="init-body"/>
end Init;

begin  -- package &pkg; initialization
   Init;
end &pkg;;
</src:fragment>
</section>

</section>

</section>

</article>
